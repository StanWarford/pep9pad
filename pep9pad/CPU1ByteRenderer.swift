//
//  CPU1ByteRenderer.swift
//  ProjectName
//
//  Created by AuthorName on 3/6/17.
//  Copyright Â© 2017 CompanyName. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class CPU1ByteRenderer : NSObject {
    

    static var registerBankColor = UIColor(red: 0.868, green: 0.782, blue: 0.687, alpha: 1.000)
    static var labelBlack = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
    static var black = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
    static var noFillColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
    
    static var addressBusColor = UIColor.CPUColors.noFillColor
    static var dataBusColor = UIColor.CPUColors.noFillColor
    static var mDRColor = UIColor.CPUColors.noFillColor
    static var cBusColor = UIColor.CPUColors.noFillColor
    static var aBusPipeColor = UIColor.CPUColors.noFillColor
    static var bBusPipeColor = UIColor.CPUColors.noFillColor
    static var blackArrow = UIColor.CPUColors.grayArrow
    static var grayArrow = UIColor.CPUColors.grayArrow
   
    
//    static var registerBankColor = UIColor(red: 0.868, green: 0.782, blue: 0.687, alpha: 1.000)
//    static var addressBusColor = UIColor(red: 1.000, green: 0.845, blue: 0.000, alpha: 1.000)
//    static var dataBusColor = UIColor(red: 1.000, green: 0.252, blue: 0.131, alpha: 1.000)
//    static var labelBlack = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
//    static var mDRColor = UIColor(red: 0.649, green: 0.906, blue: 0.000, alpha: 1.000)
//    static var cBusColor = UIColor(red: 0.295, green: 0.495, blue: 1.000, alpha: 1.000)
//    static var aBusPipeColor = UIColor(red: 1.000, green: 0.000, blue: 0.000, alpha: 1.000)
//    static var bBusPipeColor = UIColor(red: 1.000, green: 0.000, blue: 0.000, alpha: 1.000)
//    static var blackArrow = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
//    static var grayArrow = UIColor(red: 0.709, green: 0.709, blue: 0.709, alpha: 1.000)
//    static var black = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
//    static var noFillColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

    //// Drawing Methods

    @objc public dynamic class func drawIpad(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 950, height: 1024), resizing: ResizingBehavior = .aspectFit) {
        // This code was generated by Trial version of PaintCode, therefore cannot be used for commercial purposes.
        // http://www.paintcodeapp.com
        
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
      
        //// TextColumn
        //// Text Drawing
        let textRect = CGRect(x: 852, y: 41, width: 85, height: 31)
        let textTextContent = "LoadCk"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .left
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: textStyle,
            ] as [NSAttributedString.Key: Any]
        
        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
        
        
        //// Text 2 Drawing
        let text2Rect = CGRect(x: 852, y: 104, width: 19, height: 25)
        let text2TextContent = "C"
        let text2Style = NSMutableParagraphStyle()
        text2Style.alignment = .left
        let text2FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: text2Style,
            ] as [NSAttributedString.Key: Any]
        
        let text2TextHeight: CGFloat = text2TextContent.boundingRect(with: CGSize(width: text2Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text2FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text2Rect)
        text2TextContent.draw(in: CGRect(x: text2Rect.minX, y: text2Rect.minY + (text2Rect.height - text2TextHeight) / 2, width: text2Rect.width, height: text2TextHeight), withAttributes: text2FontAttributes)
        context.restoreGState()
        
        
        //// Text 3 Drawing
        let text3Rect = CGRect(x: 852, y: 134, width: 19, height: 25)
        let text3TextContent = "B"
        let text3Style = NSMutableParagraphStyle()
        text3Style.alignment = .left
        let text3FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: text3Style,
            ] as [NSAttributedString.Key: Any]
        
        let text3TextHeight: CGFloat = text3TextContent.boundingRect(with: CGSize(width: text3Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text3FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text3Rect)
        text3TextContent.draw(in: CGRect(x: text3Rect.minX, y: text3Rect.minY + (text3Rect.height - text3TextHeight) / 2, width: text3Rect.width, height: text3TextHeight), withAttributes: text3FontAttributes)
        context.restoreGState()
        
        
        //// Text 4 Drawing
        let text4Rect = CGRect(x: 852, y: 163, width: 19, height: 25)
        let text4TextContent = "A"
        let text4Style = NSMutableParagraphStyle()
        text4Style.alignment = .left
        let text4FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: text4Style,
            ] as [NSAttributedString.Key: Any]
        
        let text4TextHeight: CGFloat = text4TextContent.boundingRect(with: CGSize(width: text4Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text4FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text4Rect)
        text4TextContent.draw(in: CGRect(x: text4Rect.minX, y: text4Rect.minY + (text4Rect.height - text4TextHeight) / 2, width: text4Rect.width, height: text4TextHeight), withAttributes: text4FontAttributes)
        context.restoreGState()
        
        
        //// Text 5 Drawing
        let text5Rect = CGRect(x: 852, y: 272, width: 85, height: 31)
        let text5TextContent = "MARCk"
        let text5Style = NSMutableParagraphStyle()
        text5Style.alignment = .left
        let text5FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: text5Style,
            ] as [NSAttributedString.Key: Any]
        
        let text5TextHeight: CGFloat = text5TextContent.boundingRect(with: CGSize(width: text5Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text5FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text5Rect)
        text5TextContent.draw(in: CGRect(x: text5Rect.minX, y: text5Rect.minY + (text5Rect.height - text5TextHeight) / 2, width: text5Rect.width, height: text5TextHeight), withAttributes: text5FontAttributes)
        context.restoreGState()
        
        
        //// Text 6 Drawing
        let text6Rect = CGRect(x: 852, y: 349, width: 85, height: 31)
        let text6TextContent = "MDRCk"
        let text6Style = NSMutableParagraphStyle()
        text6Style.alignment = .left
        let text6FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: text6Style,
            ] as [NSAttributedString.Key: Any]
        
        let text6TextHeight: CGFloat = text6TextContent.boundingRect(with: CGSize(width: text6Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text6FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text6Rect)
        text6TextContent.draw(in: CGRect(x: text6Rect.minX, y: text6Rect.minY + (text6Rect.height - text6TextHeight) / 2, width: text6Rect.width, height: text6TextHeight), withAttributes: text6FontAttributes)
        context.restoreGState()
        
        
        //// Text 7 Drawing
        let text7Rect = CGRect(x: 852, y: 454, width: 85, height: 24)
        let text7TextContent = "AMux"
        let text7Style = NSMutableParagraphStyle()
        text7Style.alignment = .left
        let text7FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: text7Style,
            ] as [NSAttributedString.Key: Any]
        
        let text7TextHeight: CGFloat = text7TextContent.boundingRect(with: CGSize(width: text7Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text7FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text7Rect)
        text7TextContent.draw(in: CGRect(x: text7Rect.minX, y: text7Rect.minY + (text7Rect.height - text7TextHeight) / 2, width: text7Rect.width, height: text7TextHeight), withAttributes: text7FontAttributes)
        context.restoreGState()
        
        
        //// Text 8 Drawing
        let text8Rect = CGRect(x: 852, y: 478, width: 85, height: 24)
        let text8TextContent = "MDRMux"
        let text8Style = NSMutableParagraphStyle()
        text8Style.alignment = .left
        let text8FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: text8Style,
            ] as [NSAttributedString.Key: Any]
        
        let text8TextHeight: CGFloat = text8TextContent.boundingRect(with: CGSize(width: text8Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text8FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text8Rect)
        text8TextContent.draw(in: CGRect(x: text8Rect.minX, y: text8Rect.minY + (text8Rect.height - text8TextHeight) / 2, width: text8Rect.width, height: text8TextHeight), withAttributes: text8FontAttributes)
        context.restoreGState()
        
        
        //// Text 9 Drawing
        let text9Rect = CGRect(x: 852, y: 540, width: 85, height: 24)
        let text9TextContent = "CMux"
        let text9Style = NSMutableParagraphStyle()
        text9Style.alignment = .left
        let text9FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: text9Style,
            ] as [NSAttributedString.Key: Any]
        
        let text9TextHeight: CGFloat = text9TextContent.boundingRect(with: CGSize(width: text9Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text9FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text9Rect)
        text9TextContent.draw(in: CGRect(x: text9Rect.minX, y: text9Rect.minY + (text9Rect.height - text9TextHeight) / 2, width: text9Rect.width, height: text9TextHeight), withAttributes: text9FontAttributes)
        context.restoreGState()
        
        
        //// Text 10 Drawing
        let text10Rect = CGRect(x: 852, y: 565, width: 85, height: 24)
        let text10TextContent = "ALU"
        let text10Style = NSMutableParagraphStyle()
        text10Style.alignment = .left
        let text10FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: text10Style,
            ] as [NSAttributedString.Key: Any]
        
        let text10TextHeight: CGFloat = text10TextContent.boundingRect(with: CGSize(width: text10Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text10FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text10Rect)
        text10TextContent.draw(in: CGRect(x: text10Rect.minX, y: text10Rect.minY + (text10Rect.height - text10TextHeight) / 2, width: text10Rect.width, height: text10TextHeight), withAttributes: text10FontAttributes)
        context.restoreGState()
        
        
        //// Text 11 Drawing
        let text11Rect = CGRect(x: 852, y: 620, width: 85, height: 24)
        let text11TextContent = "CSMux"
        let text11Style = NSMutableParagraphStyle()
        text11Style.alignment = .left
        let text11FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: text11Style,
            ] as [NSAttributedString.Key: Any]
        
        let text11TextHeight: CGFloat = text11TextContent.boundingRect(with: CGSize(width: text11Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text11FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text11Rect)
        text11TextContent.draw(in: CGRect(x: text11Rect.minX, y: text11Rect.minY + (text11Rect.height - text11TextHeight) / 2, width: text11Rect.width, height: text11TextHeight), withAttributes: text11FontAttributes)
        context.restoreGState()
        
        
        //// Text 12 Drawing
        let text12Rect = CGRect(x: 852, y: 684, width: 85, height: 24)
        let text12TextContent = "SCk"
        let text12Style = NSMutableParagraphStyle()
        text12Style.alignment = .left
        let text12FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: text12Style,
            ] as [NSAttributedString.Key: Any]
        
        let text12TextHeight: CGFloat = text12TextContent.boundingRect(with: CGSize(width: text12Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text12FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text12Rect)
        text12TextContent.draw(in: CGRect(x: text12Rect.minX, y: text12Rect.minY + (text12Rect.height - text12TextHeight) / 2, width: text12Rect.width, height: text12TextHeight), withAttributes: text12FontAttributes)
        context.restoreGState()
        
        
        //// Text 13 Drawing
        let text13Rect = CGRect(x: 852, y: 722, width: 85, height: 24)
        let text13TextContent = "CCk"
        let text13Style = NSMutableParagraphStyle()
        text13Style.alignment = .left
        let text13FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: text13Style,
            ] as [NSAttributedString.Key: Any]
        
        let text13TextHeight: CGFloat = text13TextContent.boundingRect(with: CGSize(width: text13Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text13FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text13Rect)
        text13TextContent.draw(in: CGRect(x: text13Rect.minX, y: text13Rect.minY + (text13Rect.height - text13TextHeight) / 2, width: text13Rect.width, height: text13TextHeight), withAttributes: text13FontAttributes)
        context.restoreGState()
        
        
        //// Text 14 Drawing
        let text14Rect = CGRect(x: 852, y: 759, width: 85, height: 24)
        let text14TextContent = "VCk"
        let text14Style = NSMutableParagraphStyle()
        text14Style.alignment = .left
        let text14FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: text14Style,
            ] as [NSAttributedString.Key: Any]
        
        let text14TextHeight: CGFloat = text14TextContent.boundingRect(with: CGSize(width: text14Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text14FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text14Rect)
        text14TextContent.draw(in: CGRect(x: text14Rect.minX, y: text14Rect.minY + (text14Rect.height - text14TextHeight) / 2, width: text14Rect.width, height: text14TextHeight), withAttributes: text14FontAttributes)
        context.restoreGState()
        
        
        //// Text 15 Drawing
        let text15Rect = CGRect(x: 852, y: 807, width: 85, height: 24)
        let text15TextContent = "AndZ"
        let text15Style = NSMutableParagraphStyle()
        text15Style.alignment = .left
        let text15FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: text15Style,
            ] as [NSAttributedString.Key: Any]
        
        let text15TextHeight: CGFloat = text15TextContent.boundingRect(with: CGSize(width: text15Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text15FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text15Rect)
        text15TextContent.draw(in: CGRect(x: text15Rect.minX, y: text15Rect.minY + (text15Rect.height - text15TextHeight) / 2, width: text15Rect.width, height: text15TextHeight), withAttributes: text15FontAttributes)
        context.restoreGState()
        
        
        //// Text 16 Drawing
        let text16Rect = CGRect(x: 852, y: 838, width: 85, height: 24)
        let text16TextContent = "ZCk"
        let text16Style = NSMutableParagraphStyle()
        text16Style.alignment = .left
        let text16FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: text16Style,
            ] as [NSAttributedString.Key: Any]
        
        let text16TextHeight: CGFloat = text16TextContent.boundingRect(with: CGSize(width: text16Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text16FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text16Rect)
        text16TextContent.draw(in: CGRect(x: text16Rect.minX, y: text16Rect.minY + (text16Rect.height - text16TextHeight) / 2, width: text16Rect.width, height: text16TextHeight), withAttributes: text16FontAttributes)
        context.restoreGState()
        
        
        //// Text 17 Drawing
        let text17Rect = CGRect(x: 852, y: 907, width: 85, height: 24)
        let text17TextContent = "NCk"
        let text17Style = NSMutableParagraphStyle()
        text17Style.alignment = .left
        let text17FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: text17Style,
            ] as [NSAttributedString.Key: Any]
        
        let text17TextHeight: CGFloat = text17TextContent.boundingRect(with: CGSize(width: text17Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text17FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text17Rect)
        text17TextContent.draw(in: CGRect(x: text17Rect.minX, y: text17Rect.minY + (text17Rect.height - text17TextHeight) / 2, width: text17Rect.width, height: text17TextHeight), withAttributes: text17FontAttributes)
        context.restoreGState()
        
        
        //// Text 18 Drawing
        let text18Rect = CGRect(x: 852, y: 955, width: 85, height: 24)
        let text18TextContent = "MemRead"
        let text18Style = NSMutableParagraphStyle()
        text18Style.alignment = .left
        let text18FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: text18Style,
            ] as [NSAttributedString.Key: Any]
        
        let text18TextHeight: CGFloat = text18TextContent.boundingRect(with: CGSize(width: text18Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text18FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text18Rect)
        text18TextContent.draw(in: CGRect(x: text18Rect.minX, y: text18Rect.minY + (text18Rect.height - text18TextHeight) / 2, width: text18Rect.width, height: text18TextHeight), withAttributes: text18FontAttributes)
        context.restoreGState()
        
        
        //// Text 19 Drawing
        let text19Rect = CGRect(x: 852, y: 979, width: 85, height: 24)
        let text19TextContent = "MemWrite"
        let text19Style = NSMutableParagraphStyle()
        text19Style.alignment = .left
        let text19FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: text19Style,
            ] as [NSAttributedString.Key: Any]
        
        let text19TextHeight: CGFloat = text19TextContent.boundingRect(with: CGSize(width: text19Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text19FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text19Rect)
        text19TextContent.draw(in: CGRect(x: text19Rect.minX, y: text19Rect.minY + (text19Rect.height - text19TextHeight) / 2, width: text19Rect.width, height: text19TextHeight), withAttributes: text19FontAttributes)
        context.restoreGState()
        
        
        
        
        //// Lines
        //// MemWriteLine
        //// MemWrLn Drawing
        let memWrLnPath = UIBezierPath()
        memWrLnPath.move(to: CGPoint(x: 809.5, y: 966.5))
        memWrLnPath.addLine(to: CGPoint(x: 171.5, y: 966.5))
        memWrLnPath.addLine(to: CGPoint(x: 171.5, y: 422.5))
        memWrLnPath.move(to: CGPoint(x: 138.5, y: 966.5))
        memWrLnPath.addCurve(to: CGPoint(x: 171.5, y: 966.5), controlPoint1: CGPoint(x: 166.5, y: 966.5), controlPoint2: CGPoint(x: 171.5, y: 966.5))
        blackArrow.setStroke()
        memWrLnPath.lineWidth = 1
        memWrLnPath.stroke()
        
        
        //// MemWrConnector Drawing
        let memWrConnectorPath = UIBezierPath(ovalIn: CGRect(x: 169, y: 964, width: 5, height: 5))
        blackArrow.setFill()
        memWrConnectorPath.fill()
        blackArrow.setStroke()
        memWrConnectorPath.lineWidth = 1
        memWrConnectorPath.lineJoinStyle = .bevel
        memWrConnectorPath.stroke()
        
        
        //// MemWrArrow Drawing
        let memWrArrowPath = UIBezierPath()
        memWrArrowPath.move(to: CGPoint(x: 129.97, y: 966.38))
        memWrArrowPath.addLine(to: CGPoint(x: 140.28, y: 962.38))
        memWrArrowPath.addLine(to: CGPoint(x: 140.28, y: 965.38))
        memWrArrowPath.addLine(to: CGPoint(x: 140.28, y: 967.38))
        memWrArrowPath.addLine(to: CGPoint(x: 140.28, y: 970.38))
        memWrArrowPath.addLine(to: CGPoint(x: 129.97, y: 966.38))
        memWrArrowPath.close()
        blackArrow.setFill()
        memWrArrowPath.fill()
        blackArrow.setStroke()
        memWrArrowPath.lineWidth = 1
        memWrArrowPath.stroke()
        
        
        //// MemReadTopArrow Drawing
        context.saveGState()
        context.translateBy(x: 175.97, y: 415.38)
        context.rotate(by: 90 * CGFloat.pi/180)
        
        let memReadTopArrowPath = UIBezierPath()
        memReadTopArrowPath.move(to: CGPoint(x: 0, y: 4))
        memReadTopArrowPath.addLine(to: CGPoint(x: 10.31, y: 0))
        memReadTopArrowPath.addLine(to: CGPoint(x: 10.31, y: 3))
        memReadTopArrowPath.addLine(to: CGPoint(x: 10.31, y: 5))
        memReadTopArrowPath.addLine(to: CGPoint(x: 10.31, y: 8))
        memReadTopArrowPath.addLine(to: CGPoint(x: 0, y: 4))
        memReadTopArrowPath.close()
        blackArrow.setFill()
        memReadTopArrowPath.fill()
        blackArrow.setStroke()
        memReadTopArrowPath.lineWidth = 1
        memReadTopArrowPath.stroke()
        
        context.restoreGState()
        
        
        //// MemWriteval Drawing
        let memWritevalPath = UIBezierPath(rect: CGRect(x: 815.5, y: 979.5, width: 30, height: 24))
        noFillColor.setFill()
        memWritevalPath.fill()
        black.setStroke()
        memWritevalPath.lineWidth = 1
        memWritevalPath.stroke()
        
        
        
        
        //// AMuxLine
        //// AMuxLnArrow Drawing
        let aMuxLnArrowPath = UIBezierPath()
        aMuxLnArrowPath.move(to: CGPoint(x: 519.97, y: 465.38))
        aMuxLnArrowPath.addLine(to: CGPoint(x: 530.28, y: 461.38))
        aMuxLnArrowPath.addLine(to: CGPoint(x: 530.28, y: 464.38))
        aMuxLnArrowPath.addLine(to: CGPoint(x: 530.28, y: 466.38))
        aMuxLnArrowPath.addLine(to: CGPoint(x: 530.28, y: 469.38))
        aMuxLnArrowPath.addLine(to: CGPoint(x: 519.97, y: 465.38))
        aMuxLnArrowPath.close()
        blackArrow.setFill()
        aMuxLnArrowPath.fill()
        blackArrow.setStroke()
        aMuxLnArrowPath.lineWidth = 1
        aMuxLnArrowPath.stroke()
        
        
        //// AMuxLn Drawing
        let aMuxLnPath = UIBezierPath()
        aMuxLnPath.move(to: CGPoint(x: 809.5, y: 465.5))
        aMuxLnPath.addLine(to: CGPoint(x: 528.5, y: 465.5))
        blackArrow.setStroke()
        aMuxLnPath.lineWidth = 1
        aMuxLnPath.stroke()
        
        
        //// AMuxval Drawing
        let aMuxvalPath = UIBezierPath(rect: CGRect(x: 815.5, y: 453.5, width: 30, height: 24))
        noFillColor.setFill()
        aMuxvalPath.fill()
        black.setStroke()
        aMuxvalPath.lineWidth = 1
        aMuxvalPath.stroke()
        
        
        
        
        //// MARCkLine
        //// MARCkLn Drawing
        let mARCkLnPath = UIBezierPath()
        mARCkLnPath.move(to: CGPoint(x: 809.5, y: 286.5))
        mARCkLnPath.addLine(to: CGPoint(x: 314.5, y: 286.5))
        mARCkLnPath.addLine(to: CGPoint(x: 314.5, y: 271.5))
        mARCkLnPath.addLine(to: CGPoint(x: 314.5, y: 304.5))
        blackArrow.setStroke()
        mARCkLnPath.lineWidth = 1
        mARCkLnPath.stroke()
        
        
        //// MARBConnector Drawing
        context.saveGState()
        context.translateBy(x: 318.5, y: 261.38)
        context.rotate(by: 90 * CGFloat.pi/180)
        
        let mARBConnectorPath = UIBezierPath()
        mARBConnectorPath.move(to: CGPoint(x: 0, y: 4))
        mARBConnectorPath.addLine(to: CGPoint(x: 10.31, y: 0))
        mARBConnectorPath.addLine(to: CGPoint(x: 10.31, y: 3))
        mARBConnectorPath.addLine(to: CGPoint(x: 10.31, y: 5))
        mARBConnectorPath.addLine(to: CGPoint(x: 10.31, y: 8))
        mARBConnectorPath.addLine(to: CGPoint(x: 0, y: 4))
        mARBConnectorPath.close()
        blackArrow.setFill()
        mARBConnectorPath.fill()
        blackArrow.setStroke()
        mARBConnectorPath.lineWidth = 1
        mARBConnectorPath.stroke()
        
        context.restoreGState()
        
        
        //// MARAArrow Drawing
        context.saveGState()
        context.translateBy(x: 310.5, y: 314.38)
        context.rotate(by: -90 * CGFloat.pi/180)
        
        let mARAArrowPath = UIBezierPath()
        mARAArrowPath.move(to: CGPoint(x: 0, y: 4))
        mARAArrowPath.addLine(to: CGPoint(x: 10.31, y: 0))
        mARAArrowPath.addLine(to: CGPoint(x: 10.31, y: 3))
        mARAArrowPath.addLine(to: CGPoint(x: 10.31, y: 5))
        mARAArrowPath.addLine(to: CGPoint(x: 10.31, y: 8))
        mARAArrowPath.addLine(to: CGPoint(x: 0, y: 4))
        mARAArrowPath.close()
        blackArrow.setFill()
        mARAArrowPath.fill()
        blackArrow.setStroke()
        mARAArrowPath.lineWidth = 1
        mARAArrowPath.stroke()
        
        context.restoreGState()
        
        
        //// MARConnector Drawing
        let mARConnectorPath = UIBezierPath(ovalIn: CGRect(x: 312, y: 284, width: 5, height: 5))
        blackArrow.setFill()
        mARConnectorPath.fill()
        blackArrow.setStroke()
        mARConnectorPath.lineWidth = 1
        mARConnectorPath.lineJoinStyle = .bevel
        mARConnectorPath.stroke()
        
        
        //// MARCkval Drawing
        let mARCkvalPath = UIBezierPath(roundedRect: CGRect(x: 816, y: 274.5, width: 24, height: 24), cornerRadius: 5)
        noFillColor.setFill()
        mARCkvalPath.fill()
        black.setStroke()
        mARCkvalPath.lineWidth = 1
        mARCkvalPath.stroke()
        
        
        
        
        //// ALUToCBit
        //// ALUToCLn Drawing
        let aLUToCLnPath = UIBezierPath()
        aLUToCLnPath.move(to: CGPoint(x: 576.5, y: 604.5))
        aLUToCLnPath.addLine(to: CGPoint(x: 576.5, y: 685.5))
        aLUToCLnPath.addLine(to: CGPoint(x: 576.5, y: 696.5))
        aLUToCLnPath.addLine(to: CGPoint(x: 576.5, y: 734.5))
        aLUToCLnPath.addLine(to: CGPoint(x: 671.5, y: 734.5))
        aLUToCLnPath.move(to: CGPoint(x: 672.5, y: 694.5))
        aLUToCLnPath.addLine(to: CGPoint(x: 576.5, y: 694.5))
        blackArrow.setStroke()
        aLUToCLnPath.lineWidth = 1
        aLUToCLnPath.stroke()
        
        
        //// CArrow Drawing
        context.saveGState()
        context.translateBy(x: 674.97, y: 738.38)
        context.rotate(by: -180 * CGFloat.pi/180)
        
        let cArrowPath = UIBezierPath()
        cArrowPath.move(to: CGPoint(x: 0, y: 4))
        cArrowPath.addLine(to: CGPoint(x: 10.31, y: 0))
        cArrowPath.addLine(to: CGPoint(x: 10.31, y: 3))
        cArrowPath.addLine(to: CGPoint(x: 10.31, y: 5))
        cArrowPath.addLine(to: CGPoint(x: 10.31, y: 8))
        cArrowPath.addLine(to: CGPoint(x: 0, y: 4))
        cArrowPath.close()
        blackArrow.setFill()
        cArrowPath.fill()
        blackArrow.setStroke()
        cArrowPath.lineWidth = 1
        cArrowPath.stroke()
        
        context.restoreGState()
        
        
        //// SArrow Drawing
        context.saveGState()
        context.translateBy(x: 674.97, y: 698.38)
        context.rotate(by: -180 * CGFloat.pi/180)
        
        let sArrowPath = UIBezierPath()
        sArrowPath.move(to: CGPoint(x: 0, y: 4))
        sArrowPath.addLine(to: CGPoint(x: 10.31, y: 0))
        sArrowPath.addLine(to: CGPoint(x: 10.31, y: 3))
        sArrowPath.addLine(to: CGPoint(x: 10.31, y: 5))
        sArrowPath.addLine(to: CGPoint(x: 10.31, y: 8))
        sArrowPath.addLine(to: CGPoint(x: 0, y: 4))
        sArrowPath.close()
        blackArrow.setFill()
        sArrowPath.fill()
        blackArrow.setStroke()
        sArrowPath.lineWidth = 1
        sArrowPath.stroke()
        
        context.restoreGState()
        
        
        //// CBitConnector Drawing
        let cBitConnectorPath = UIBezierPath(ovalIn: CGRect(x: 574, y: 692, width: 5, height: 5))
        blackArrow.setFill()
        cBitConnectorPath.fill()
        blackArrow.setStroke()
        cBitConnectorPath.lineWidth = 1
        cBitConnectorPath.lineJoinStyle = .bevel
        cBitConnectorPath.stroke()
        
        
        
        
        //// ALUToZBit
        //// ALUToANDZLn Drawing
        let aLUToANDZLnPath = UIBezierPath()
        aLUToANDZLnPath.move(to: CGPoint(x: 534.5, y: 604.5))
        aLUToANDZLnPath.addLine(to: CGPoint(x: 534.5, y: 851.5))
        aLUToANDZLnPath.addLine(to: CGPoint(x: 588.5, y: 851.5))
        blackArrow.setStroke()
        aLUToANDZLnPath.lineWidth = 1
        aLUToANDZLnPath.stroke()
        
        
        //// LeftANDZArrow Drawing
        context.saveGState()
        context.translateBy(x: 591.97, y: 855.38)
        context.rotate(by: -180 * CGFloat.pi/180)
        
        let leftANDZArrowPath = UIBezierPath()
        leftANDZArrowPath.move(to: CGPoint(x: 0, y: 4))
        leftANDZArrowPath.addLine(to: CGPoint(x: 10.31, y: 0))
        leftANDZArrowPath.addLine(to: CGPoint(x: 10.31, y: 3))
        leftANDZArrowPath.addLine(to: CGPoint(x: 10.31, y: 5))
        leftANDZArrowPath.addLine(to: CGPoint(x: 10.31, y: 8))
        leftANDZArrowPath.addLine(to: CGPoint(x: 0, y: 4))
        leftANDZArrowPath.close()
        blackArrow.setFill()
        leftANDZArrowPath.fill()
        blackArrow.setStroke()
        leftANDZArrowPath.lineWidth = 1
        leftANDZArrowPath.stroke()
        
        context.restoreGState()
        
        
        //// ANDZToZLn Drawing
        let aNDZToZLnPath = UIBezierPath()
        aNDZToZLnPath.move(to: CGPoint(x: 650.5, y: 850.5))
        aNDZToZLnPath.addLine(to: CGPoint(x: 665.5, y: 850.5))
        UIColor.black.setStroke()
        aNDZToZLnPath.lineWidth = 1
        aNDZToZLnPath.stroke()
        
        
        //// ANDZToZArrow Drawing
        context.saveGState()
        context.translateBy(x: 674.97, y: 854.38)
        context.rotate(by: -180 * CGFloat.pi/180)
        
        let aNDZToZArrowPath = UIBezierPath()
        aNDZToZArrowPath.move(to: CGPoint(x: 0, y: 4))
        aNDZToZArrowPath.addLine(to: CGPoint(x: 10.31, y: 0))
        aNDZToZArrowPath.addLine(to: CGPoint(x: 10.31, y: 3))
        aNDZToZArrowPath.addLine(to: CGPoint(x: 10.31, y: 5))
        aNDZToZArrowPath.addLine(to: CGPoint(x: 10.31, y: 8))
        aNDZToZArrowPath.addLine(to: CGPoint(x: 0, y: 4))
        aNDZToZArrowPath.close()
        blackArrow.setFill()
        aNDZToZArrowPath.fill()
        blackArrow.setStroke()
        aNDZToZArrowPath.lineWidth = 1
        aNDZToZArrowPath.stroke()
        
        context.restoreGState()
        
        
        
        
        //// ALUToVBit
        //// ALUToVLn Drawing
        let aLUToVLnPath = UIBezierPath()
        aLUToVLnPath.move(to: CGPoint(x: 554.5, y: 604.5))
        aLUToVLnPath.addLine(to: CGPoint(x: 554.5, y: 772.5))
        aLUToVLnPath.addLine(to: CGPoint(x: 670.5, y: 772.5))
        blackArrow.setStroke()
        aLUToVLnPath.lineWidth = 1
        aLUToVLnPath.stroke()
        
        
        //// VArrow Drawing
        context.saveGState()
        context.translateBy(x: 674.97, y: 776.38)
        context.rotate(by: -180 * CGFloat.pi/180)
        
        let vArrowPath = UIBezierPath()
        vArrowPath.move(to: CGPoint(x: 0, y: 4))
        vArrowPath.addLine(to: CGPoint(x: 10.31, y: 0))
        vArrowPath.addLine(to: CGPoint(x: 10.31, y: 3))
        vArrowPath.addLine(to: CGPoint(x: 10.31, y: 5))
        vArrowPath.addLine(to: CGPoint(x: 10.31, y: 8))
        vArrowPath.addLine(to: CGPoint(x: 0, y: 4))
        vArrowPath.close()
        blackArrow.setFill()
        vArrowPath.fill()
        blackArrow.setStroke()
        vArrowPath.lineWidth = 1
        vArrowPath.stroke()
        
        context.restoreGState()
        
        
        
        
        //// ALUToNBit
        //// ALUToNBitLn Drawing
        let aLUToNBitLnPath = UIBezierPath()
        aLUToNBitLnPath.move(to: CGPoint(x: 512.5, y: 604.5))
        aLUToNBitLnPath.addLine(to: CGPoint(x: 512.5, y: 919.5))
        aLUToNBitLnPath.addLine(to: CGPoint(x: 669.5, y: 919.5))
        blackArrow.setStroke()
        aLUToNBitLnPath.lineWidth = 1
        aLUToNBitLnPath.stroke()
        
        
        //// ALUToNBitArrow Drawing
        context.saveGState()
        context.translateBy(x: 674.97, y: 923.38)
        context.rotate(by: -180 * CGFloat.pi/180)
        
        let aLUToNBitArrowPath = UIBezierPath()
        aLUToNBitArrowPath.move(to: CGPoint(x: 0, y: 4))
        aLUToNBitArrowPath.addLine(to: CGPoint(x: 10.31, y: 0))
        aLUToNBitArrowPath.addLine(to: CGPoint(x: 10.31, y: 3))
        aLUToNBitArrowPath.addLine(to: CGPoint(x: 10.31, y: 5))
        aLUToNBitArrowPath.addLine(to: CGPoint(x: 10.31, y: 8))
        aLUToNBitArrowPath.addLine(to: CGPoint(x: 0, y: 4))
        aLUToNBitArrowPath.close()
        blackArrow.setFill()
        aLUToNBitArrowPath.fill()
        blackArrow.setStroke()
        aLUToNBitArrowPath.lineWidth = 1
        aLUToNBitArrowPath.stroke()
        
        context.restoreGState()
        
        
        
        
        //// ZBitLine
        //// ZInLnArrow Drawing
        let zInLnArrowPath = UIBezierPath()
        zInLnArrowPath.move(to: CGPoint(x: 409.97, y: 799.38))
        zInLnArrowPath.addLine(to: CGPoint(x: 420.28, y: 795.38))
        zInLnArrowPath.addLine(to: CGPoint(x: 420.28, y: 798.38))
        zInLnArrowPath.addLine(to: CGPoint(x: 420.28, y: 800.38))
        zInLnArrowPath.addLine(to: CGPoint(x: 420.28, y: 803.38))
        zInLnArrowPath.addLine(to: CGPoint(x: 409.97, y: 799.38))
        zInLnArrowPath.close()
        blackArrow.setFill()
        zInLnArrowPath.fill()
        blackArrow.setStroke()
        zInLnArrowPath.lineWidth = 1
        zInLnArrowPath.stroke()
        
        
        //// AndZInBottomArrow Drawing
        context.saveGState()
        context.translateBy(x: 619.07, y: 875.88)
        context.rotate(by: -90 * CGFloat.pi/180)
        
        let andZInBottomArrowPath = UIBezierPath()
        andZInBottomArrowPath.move(to: CGPoint(x: 11.11, y: 4))
        andZInBottomArrowPath.addLine(to: CGPoint(x: 1, y: 0))
        andZInBottomArrowPath.addLine(to: CGPoint(x: 1, y: 3))
        andZInBottomArrowPath.addLine(to: CGPoint(x: 1, y: 5))
        andZInBottomArrowPath.addLine(to: CGPoint(x: 1, y: 8))
        andZInBottomArrowPath.addLine(to: CGPoint(x: 11.11, y: 4))
        andZInBottomArrowPath.close()
        blackArrow.setFill()
        andZInBottomArrowPath.fill()
        blackArrow.setStroke()
        andZInBottomArrowPath.lineWidth = 1
        andZInBottomArrowPath.stroke()
        
        context.restoreGState()
        
        
        //// AndZConnector Drawing
        let andZConnectorPath = UIBezierPath(ovalIn: CGRect(x: 620.68, y: 878.13, width: 5, height: 5))
        blackArrow.setFill()
        andZConnectorPath.fill()
        blackArrow.setStroke()
        andZConnectorPath.lineWidth = 1
        andZConnectorPath.stroke()
        
        
        //// ZBitLn Drawing
        let zBitLnPath = UIBezierPath()
        zBitLnPath.move(to: CGPoint(x: 623.18, y: 873.19))
        zBitLnPath.addLine(to: CGPoint(x: 623.18, y: 880.44))
        zBitLnPath.addLine(to: CGPoint(x: 623.18, y: 873.19))
        zBitLnPath.close()
        zBitLnPath.move(to: CGPoint(x: 690.5, y: 862.5))
        zBitLnPath.addLine(to: CGPoint(x: 690.5, y: 880.5))
        zBitLnPath.addLine(to: CGPoint(x: 450.5, y: 880.5))
        zBitLnPath.addLine(to: CGPoint(x: 450.5, y: 799.5))
        zBitLnPath.addLine(to: CGPoint(x: 414.5, y: 799.5))
        blackArrow.setStroke()
        zBitLnPath.lineWidth = 1
        zBitLnPath.stroke()
        
        
        
        
        //// VBitLine
        //// VBitLn Drawing
        let vBitLnPath = UIBezierPath()
        vBitLnPath.move(to: CGPoint(x: 689.5, y: 784.5))
        vBitLnPath.addLine(to: CGPoint(x: 689.5, y: 804.5))
        vBitLnPath.addLine(to: CGPoint(x: 473.5, y: 804.5))
        vBitLnPath.addLine(to: CGPoint(x: 473.5, y: 776.5))
        vBitLnPath.addLine(to: CGPoint(x: 416.5, y: 776.5))
        blackArrow.setStroke()
        vBitLnPath.lineWidth = 1
        vBitLnPath.stroke()
        
        
        //// VInLnArrow Drawing
        let vInLnArrowPath = UIBezierPath()
        vInLnArrowPath.move(to: CGPoint(x: 409.97, y: 776.38))
        vInLnArrowPath.addLine(to: CGPoint(x: 420.28, y: 772.38))
        vInLnArrowPath.addLine(to: CGPoint(x: 420.28, y: 775.38))
        vInLnArrowPath.addLine(to: CGPoint(x: 420.28, y: 777.38))
        vInLnArrowPath.addLine(to: CGPoint(x: 420.28, y: 780.38))
        vInLnArrowPath.addLine(to: CGPoint(x: 409.97, y: 776.38))
        vInLnArrowPath.close()
        blackArrow.setFill()
        vInLnArrowPath.fill()
        blackArrow.setStroke()
        vInLnArrowPath.lineWidth = 1
        vInLnArrowPath.stroke()
        
        
        
        
        //// CBitLine
        //// CIBitLn Drawing
        let cIBitLnPath = UIBezierPath()
        cIBitLnPath.move(to: CGPoint(x: 690.5, y: 745.5))
        cIBitLnPath.addLine(to: CGPoint(x: 690.5, y: 753.5))
        cIBitLnPath.addLine(to: CGPoint(x: 414.5, y: 753.5))
        blackArrow.setStroke()
        cIBitLnPath.lineWidth = 1
        cIBitLnPath.stroke()
        
        
        //// CInLnArrow Drawing
        let cInLnArrowPath = UIBezierPath()
        cInLnArrowPath.move(to: CGPoint(x: 409.97, y: 753.38))
        cInLnArrowPath.addLine(to: CGPoint(x: 420.28, y: 749.38))
        cInLnArrowPath.addLine(to: CGPoint(x: 420.28, y: 752.38))
        cInLnArrowPath.addLine(to: CGPoint(x: 420.28, y: 754.38))
        cInLnArrowPath.addLine(to: CGPoint(x: 420.28, y: 757.38))
        cInLnArrowPath.addLine(to: CGPoint(x: 409.97, y: 753.38))
        cInLnArrowPath.close()
        blackArrow.setFill()
        cInLnArrowPath.fill()
        blackArrow.setStroke()
        cInLnArrowPath.lineWidth = 1
        cInLnArrowPath.stroke()
        
        
        
        
        //// NBitLine
        context.saveGState()
        context.translateBy(x: 437.83, y: 885.38)
        
        
        
        //// NBitInArrow Drawing
        let nBitInArrowPath = UIBezierPath()
        nBitInArrowPath.move(to: CGPoint(x: -27.86, y: -64))
        nBitInArrowPath.addLine(to: CGPoint(x: -17.55, y: -68))
        nBitInArrowPath.addLine(to: CGPoint(x: -17.55, y: -65))
        nBitInArrowPath.addLine(to: CGPoint(x: -17.55, y: -63))
        nBitInArrowPath.addLine(to: CGPoint(x: -17.55, y: -60))
        nBitInArrowPath.addLine(to: CGPoint(x: -27.86, y: -64))
        nBitInArrowPath.close()
        blackArrow.setFill()
        nBitInArrowPath.fill()
        blackArrow.setStroke()
        nBitInArrowPath.lineWidth = 1
        nBitInArrowPath.stroke()
        
        
        //// NBitLn Drawing
        let nBitLnPath = UIBezierPath()
        nBitLnPath.move(to: CGPoint(x: 252.67, y: 55.12))
        nBitLnPath.addLine(to: CGPoint(x: -5.33, y: 55.12))
        nBitLnPath.addLine(to: CGPoint(x: -5.33, y: -63.88))
        nBitLnPath.addLine(to: CGPoint(x: -23.33, y: -63.88))
        nBitLnPath.move(to: CGPoint(x: 252.67, y: 55.12))
        nBitLnPath.addLine(to: CGPoint(x: 252.67, y: 47.12))
        blackArrow.setStroke()
        nBitLnPath.lineWidth = 1
        nBitLnPath.lineCapStyle = .square
        nBitLnPath.stroke()
        
        
        
        context.restoreGState()
        
        
        //// MemReadLine
        context.saveGState()
        context.translateBy(x: 131.13, y: 987)
        
        
        
        //// MemRdLn Drawing
        let memRdLnPath = UIBezierPath()
        memRdLnPath.move(to: CGPoint(x: 8.56, y: 4.5))
        memRdLnPath.addLine(to: CGPoint(x: 678.37, y: 4.5))
        grayArrow.setStroke()
        memRdLnPath.lineWidth = 1
        memRdLnPath.stroke()
        
        
        //// MemRdArrow Drawing
        let memRdArrowPath = UIBezierPath()
        memRdArrowPath.move(to: CGPoint(x: 0.87, y: 4.5))
        memRdArrowPath.addLine(to: CGPoint(x: 10.98, y: 0.5))
        memRdArrowPath.addLine(to: CGPoint(x: 10.98, y: 3.5))
        memRdArrowPath.addLine(to: CGPoint(x: 10.98, y: 5.5))
        memRdArrowPath.addLine(to: CGPoint(x: 10.98, y: 8.5))
        memRdArrowPath.addLine(to: CGPoint(x: 0.87, y: 4.5))
        memRdArrowPath.close()
        grayArrow.setFill()
        memRdArrowPath.fill()
        grayArrow.setStroke()
        memRdArrowPath.lineWidth = 1
        memRdArrowPath.stroke()
        
        
        //// MemReadval Drawing
        let memReadvalPath = UIBezierPath(rect: CGRect(x: 684.37, y: -32.5, width: 30, height: 24))
        noFillColor.setFill()
        memReadvalPath.fill()
        black.setStroke()
        memReadvalPath.lineWidth = 1
        memReadvalPath.stroke()
        
        
        
        context.restoreGState()
        
        
        //// MDRCkLine
        //// MDRCkval Drawing
        let mDRCkvalPath = UIBezierPath(roundedRect: CGRect(x: 816, y: 352.5, width: 24, height: 24), cornerRadius: 5)
        noFillColor.setFill()
        mDRCkvalPath.fill()
        black.setStroke()
        mDRCkvalPath.lineWidth = 1
        mDRCkvalPath.stroke()
        
        
        //// MDRCkLn Drawing
        let mDRCkLnPath = UIBezierPath()
        mDRCkLnPath.move(to: CGPoint(x: 282.5, y: 386.5))
        mDRCkLnPath.addLine(to: CGPoint(x: 282.5, y: 364.5))
        mDRCkLnPath.addLine(to: CGPoint(x: 809.5, y: 364.5))
        blackArrow.setStroke()
        mDRCkLnPath.lineWidth = 1
        mDRCkLnPath.stroke()
        
        
        //// MDRCkArrow Drawing
        context.saveGState()
        context.translateBy(x: 278.5, y: 389.38)
        context.rotate(by: -90 * CGFloat.pi/180)
        
        let mDRCkArrowPath = UIBezierPath()
        mDRCkArrowPath.move(to: CGPoint(x: 0, y: 4))
        mDRCkArrowPath.addLine(to: CGPoint(x: 10.31, y: 0))
        mDRCkArrowPath.addLine(to: CGPoint(x: 10.31, y: 3))
        mDRCkArrowPath.addLine(to: CGPoint(x: 10.31, y: 5))
        mDRCkArrowPath.addLine(to: CGPoint(x: 10.31, y: 8))
        mDRCkArrowPath.addLine(to: CGPoint(x: 0, y: 4))
        mDRCkArrowPath.close()
        blackArrow.setFill()
        mDRCkArrowPath.fill()
        blackArrow.setStroke()
        mDRCkArrowPath.lineWidth = 1
        mDRCkArrowPath.stroke()
        
        context.restoreGState()
        
        
        
        
        //// CLine
        //// CLn Drawing
        let cLnPath = UIBezierPath()
        cLnPath.move(to: CGPoint(x: 729.5, y: 115.5))
        cLnPath.addLine(to: CGPoint(x: 809.5, y: 115.5))
        cLnPath.move(to: CGPoint(x: 764.5, y: 105.5))
        cLnPath.addLine(to: CGPoint(x: 785.5, y: 126.5))
        blackArrow.setStroke()
        cLnPath.lineWidth = 1
        cLnPath.stroke()
        
        
        //// CArr Drawing
        let cArrPath = UIBezierPath()
        cArrPath.move(to: CGPoint(x: 719.97, y: 115.38))
        cArrPath.addLine(to: CGPoint(x: 730.28, y: 111.38))
        cArrPath.addLine(to: CGPoint(x: 730.28, y: 114.38))
        cArrPath.addLine(to: CGPoint(x: 730.28, y: 116.38))
        cArrPath.addLine(to: CGPoint(x: 730.28, y: 119.38))
        cArrPath.addLine(to: CGPoint(x: 719.97, y: 115.38))
        cArrPath.close()
        blackArrow.setFill()
        cArrPath.fill()
        blackArrow.setStroke()
        cArrPath.lineWidth = 1
        cArrPath.stroke()
        
        
        //// CText Drawing
        let cTextRect = CGRect(x: 773, y: 102, width: 8, height: 11)
        let cTextTextContent = "5"
        let cTextStyle = NSMutableParagraphStyle()
        cTextStyle.alignment = .left
        let cTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: 11),
            .foregroundColor: UIColor.black,
            .paragraphStyle: cTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let cTextTextHeight: CGFloat = cTextTextContent.boundingRect(with: CGSize(width: cTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: cTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: cTextRect)
        cTextTextContent.draw(in: CGRect(x: cTextRect.minX, y: cTextRect.minY + (cTextRect.height - cTextTextHeight) / 2, width: cTextRect.width, height: cTextTextHeight), withAttributes: cTextFontAttributes)
        context.restoreGState()
        
        
        //// C Drawing
        let cPath = UIBezierPath(rect: CGRect(x: 815, y: 104, width: 30, height: 24))
        noFillColor.setFill()
        cPath.fill()
        black.setStroke()
        cPath.lineWidth = 1
        cPath.stroke()
        
        
        
        
        //// BLine
        //// BLn Drawing
        let bLnPath = UIBezierPath()
        bLnPath.move(to: CGPoint(x: 729.5, y: 145.5))
        bLnPath.addLine(to: CGPoint(x: 809.5, y: 145.5))
        bLnPath.move(to: CGPoint(x: 764.5, y: 135.5))
        bLnPath.addLine(to: CGPoint(x: 785.5, y: 156.5))
        blackArrow.setStroke()
        bLnPath.lineWidth = 1
        bLnPath.stroke()
        
        
        //// BArr Drawing
        let bArrPath = UIBezierPath()
        bArrPath.move(to: CGPoint(x: 719.97, y: 145.38))
        bArrPath.addLine(to: CGPoint(x: 730.28, y: 141.38))
        bArrPath.addLine(to: CGPoint(x: 730.28, y: 144.38))
        bArrPath.addLine(to: CGPoint(x: 730.28, y: 146.38))
        bArrPath.addLine(to: CGPoint(x: 730.28, y: 149.38))
        bArrPath.addLine(to: CGPoint(x: 719.97, y: 145.38))
        bArrPath.close()
        blackArrow.setFill()
        bArrPath.fill()
        blackArrow.setStroke()
        bArrPath.lineWidth = 1
        bArrPath.stroke()
        
        
        //// BText Drawing
        let bTextRect = CGRect(x: 773, y: 132, width: 8, height: 11)
        let bTextTextContent = "5"
        let bTextStyle = NSMutableParagraphStyle()
        bTextStyle.alignment = .left
        let bTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: 11),
            .foregroundColor: UIColor.black,
            .paragraphStyle: bTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let bTextTextHeight: CGFloat = bTextTextContent.boundingRect(with: CGSize(width: bTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: bTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: bTextRect)
        bTextTextContent.draw(in: CGRect(x: bTextRect.minX, y: bTextRect.minY + (bTextRect.height - bTextTextHeight) / 2, width: bTextRect.width, height: bTextTextHeight), withAttributes: bTextFontAttributes)
        context.restoreGState()
        
        
        //// B Drawing
        let bPath = UIBezierPath(rect: CGRect(x: 815, y: 133.5, width: 30, height: 24))
        noFillColor.setFill()
        bPath.fill()
        black.setStroke()
        bPath.lineWidth = 1
        bPath.stroke()
        
        
        
        
        //// AndZLine
        //// AndZLn Drawing
        let andZLnPath = UIBezierPath()
        andZLnPath.move(to: CGPoint(x: 809.5, y: 818.5))
        andZLnPath.addLine(to: CGPoint(x: 622.5, y: 818.5))
        andZLnPath.addLine(to: CGPoint(x: 622.5, y: 825.5))
        blackArrow.setStroke()
        andZLnPath.lineWidth = 1
        andZLnPath.stroke()
        
        
        //// AndZArrow Drawing
        context.saveGState()
        context.translateBy(x: 618.5, y: 834.38)
        context.rotate(by: -90 * CGFloat.pi/180)
        
        let andZArrowPath = UIBezierPath()
        andZArrowPath.move(to: CGPoint(x: 0, y: 4))
        andZArrowPath.addLine(to: CGPoint(x: 10.31, y: 0))
        andZArrowPath.addLine(to: CGPoint(x: 10.31, y: 3))
        andZArrowPath.addLine(to: CGPoint(x: 10.31, y: 5))
        andZArrowPath.addLine(to: CGPoint(x: 10.31, y: 8))
        andZArrowPath.addLine(to: CGPoint(x: 0, y: 4))
        andZArrowPath.close()
        blackArrow.setFill()
        andZArrowPath.fill()
        blackArrow.setStroke()
        andZArrowPath.lineWidth = 1
        andZArrowPath.stroke()
        
        context.restoreGState()
        
        
        //// AndZval Drawing
        let andZvalPath = UIBezierPath(rect: CGRect(x: 815.5, y: 806.5, width: 30, height: 24))
        noFillColor.setFill()
        andZvalPath.fill()
        black.setStroke()
        andZvalPath.lineWidth = 1
        andZvalPath.stroke()
        
        
        
        
        //// ALine
        //// ALn Drawing
        let aLnPath = UIBezierPath()
        aLnPath.move(to: CGPoint(x: 729.5, y: 175.5))
        aLnPath.addLine(to: CGPoint(x: 809.5, y: 175.5))
        aLnPath.move(to: CGPoint(x: 764.5, y: 165.5))
        aLnPath.addLine(to: CGPoint(x: 785.5, y: 186.5))
        blackArrow.setStroke()
        aLnPath.lineWidth = 1
        aLnPath.stroke()
        
        
        //// AArr Drawing
        let aArrPath = UIBezierPath()
        aArrPath.move(to: CGPoint(x: 719.97, y: 175.38))
        aArrPath.addLine(to: CGPoint(x: 730.28, y: 171.38))
        aArrPath.addLine(to: CGPoint(x: 730.28, y: 174.38))
        aArrPath.addLine(to: CGPoint(x: 730.28, y: 176.38))
        aArrPath.addLine(to: CGPoint(x: 730.28, y: 179.38))
        aArrPath.addLine(to: CGPoint(x: 719.97, y: 175.38))
        aArrPath.close()
        blackArrow.setFill()
        aArrPath.fill()
        blackArrow.setStroke()
        aArrPath.lineWidth = 1
        aArrPath.stroke()
        
        
        //// AText Drawing
        let aTextRect = CGRect(x: 773, y: 162, width: 8, height: 11)
        let aTextTextContent = "5"
        let aTextStyle = NSMutableParagraphStyle()
        aTextStyle.alignment = .left
        let aTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: 11),
            .foregroundColor: UIColor.black,
            .paragraphStyle: aTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let aTextTextHeight: CGFloat = aTextTextContent.boundingRect(with: CGSize(width: aTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: aTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: aTextRect)
        aTextTextContent.draw(in: CGRect(x: aTextRect.minX, y: aTextRect.minY + (aTextRect.height - aTextTextHeight) / 2, width: aTextRect.width, height: aTextTextHeight), withAttributes: aTextFontAttributes)
        context.restoreGState()
        
        
        //// Aval Drawing
        let avalPath = UIBezierPath(rect: CGRect(x: 815, y: 163.5, width: 30, height: 24))
        noFillColor.setFill()
        avalPath.fill()
        black.setStroke()
        avalPath.lineWidth = 1
        avalPath.stroke()
        
        
        
        
        //// LoadCkLine
        //// LoadCkArrow Drawing
        let loadCkArrowPath = UIBezierPath()
        loadCkArrowPath.move(to: CGPoint(x: 718.97, y: 54.38))
        loadCkArrowPath.addLine(to: CGPoint(x: 729.28, y: 50.38))
        loadCkArrowPath.addLine(to: CGPoint(x: 729.28, y: 53.38))
        loadCkArrowPath.addLine(to: CGPoint(x: 729.28, y: 55.38))
        loadCkArrowPath.addLine(to: CGPoint(x: 729.28, y: 58.38))
        loadCkArrowPath.addLine(to: CGPoint(x: 718.97, y: 54.38))
        loadCkArrowPath.close()
        blackArrow.setFill()
        loadCkArrowPath.fill()
        blackArrow.setStroke()
        loadCkArrowPath.lineWidth = 1
        loadCkArrowPath.stroke()
        
        
        //// LoadCkLn Drawing
        let loadCkLnPath = UIBezierPath()
        loadCkLnPath.move(to: CGPoint(x: 809.5, y: 54.5))
        loadCkLnPath.addLine(to: CGPoint(x: 729.5, y: 54.5))
        blackArrow.setStroke()
        loadCkLnPath.lineWidth = 1
        loadCkLnPath.stroke()
        
        
        //// LoadCkval Drawing
        let loadCkvalPath = UIBezierPath(roundedRect: CGRect(x: 816, y: 43, width: 24, height: 24), cornerRadius: 5)
        noFillColor.setFill()
        loadCkvalPath.fill()
        black.setStroke()
        loadCkvalPath.lineWidth = 1
        loadCkvalPath.stroke()
        
        
        
        
        //// MDRMuxLine
        //// MDRMuxLn Drawing
        let mDRMuxLnPath = UIBezierPath()
        mDRMuxLnPath.move(to: CGPoint(x: 336.5, y: 456.5))
        mDRMuxLnPath.addLine(to: CGPoint(x: 364.5, y: 456.5))
        mDRMuxLnPath.addLine(to: CGPoint(x: 364.5, y: 490.5))
        mDRMuxLnPath.addLine(to: CGPoint(x: 809.5, y: 490.5))
        blackArrow.setStroke()
        mDRMuxLnPath.lineWidth = 1
        mDRMuxLnPath.stroke()
        
        
        //// MDRMuxLnArrow Drawing
        let mDRMuxLnArrowPath = UIBezierPath()
        mDRMuxLnArrowPath.move(to: CGPoint(x: 333.97, y: 456.38))
        mDRMuxLnArrowPath.addLine(to: CGPoint(x: 344.28, y: 452.38))
        mDRMuxLnArrowPath.addLine(to: CGPoint(x: 344.28, y: 455.38))
        mDRMuxLnArrowPath.addLine(to: CGPoint(x: 344.28, y: 457.38))
        mDRMuxLnArrowPath.addLine(to: CGPoint(x: 344.28, y: 460.38))
        mDRMuxLnArrowPath.addLine(to: CGPoint(x: 333.97, y: 456.38))
        mDRMuxLnArrowPath.close()
        blackArrow.setFill()
        mDRMuxLnArrowPath.fill()
        blackArrow.setStroke()
        mDRMuxLnArrowPath.lineWidth = 1
        mDRMuxLnArrowPath.stroke()
        
        
        //// MDRMuxval Drawing
        let mDRMuxvalPath = UIBezierPath(rect: CGRect(x: 815.5, y: 478.5, width: 30, height: 24))
        noFillColor.setFill()
        mDRMuxvalPath.fill()
        black.setStroke()
        mDRMuxvalPath.lineWidth = 1
        mDRMuxvalPath.stroke()
        
        
        
        
        //// ALULine
        //// ALULines Drawing
        let aLULinesPath = UIBezierPath()
        aLULinesPath.move(to: CGPoint(x: 615.5, y: 577.5))
        aLULinesPath.addLine(to: CGPoint(x: 809.5, y: 577.5))
        aLULinesPath.move(to: CGPoint(x: 730.5, y: 567.5))
        aLULinesPath.addLine(to: CGPoint(x: 751.5, y: 588.5))
        blackArrow.setStroke()
        aLULinesPath.lineWidth = 1
        aLULinesPath.stroke()
        
        
        //// ALUArrow Drawing
        let aLUArrowPath = UIBezierPath()
        aLUArrowPath.move(to: CGPoint(x: 604.97, y: 577.38))
        aLUArrowPath.addLine(to: CGPoint(x: 615.28, y: 573.38))
        aLUArrowPath.addLine(to: CGPoint(x: 615.28, y: 576.38))
        aLUArrowPath.addLine(to: CGPoint(x: 615.28, y: 578.38))
        aLUArrowPath.addLine(to: CGPoint(x: 615.28, y: 581.38))
        aLUArrowPath.addLine(to: CGPoint(x: 604.97, y: 577.38))
        aLUArrowPath.close()
        blackArrow.setFill()
        aLUArrowPath.fill()
        blackArrow.setStroke()
        aLUArrowPath.lineWidth = 1
        aLUArrowPath.stroke()
        
        
        //// ALULinesText Drawing
        let aLULinesTextRect = CGRect(x: 739, y: 566, width: 8, height: 9)
        let aLULinesTextTextContent = "4"
        let aLULinesTextStyle = NSMutableParagraphStyle()
        aLULinesTextStyle.alignment = .left
        let aLULinesTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: 11),
            .foregroundColor: UIColor.black,
            .paragraphStyle: aLULinesTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let aLULinesTextTextHeight: CGFloat = aLULinesTextTextContent.boundingRect(with: CGSize(width: aLULinesTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: aLULinesTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: aLULinesTextRect)
        aLULinesTextTextContent.draw(in: CGRect(x: aLULinesTextRect.minX, y: aLULinesTextRect.minY + (aLULinesTextRect.height - aLULinesTextTextHeight) / 2, width: aLULinesTextRect.width, height: aLULinesTextTextHeight), withAttributes: aLULinesTextFontAttributes)
        context.restoreGState()
        
        
        //// ALUval Drawing
        let aLUvalPath = UIBezierPath(rect: CGRect(x: 815.5, y: 565.5, width: 30, height: 24))
        noFillColor.setFill()
        aLUvalPath.fill()
        black.setStroke()
        aLUvalPath.lineWidth = 1
        aLUvalPath.stroke()
        
        
        
        
        //// CMuxLine
        //// CMuxLn Drawing
        let cMuxLnPath = UIBezierPath()
        cMuxLnPath.move(to: CGPoint(x: 360.5, y: 578.5))
        cMuxLnPath.addLine(to: CGPoint(x: 360.5, y: 552.5))
        cMuxLnPath.addLine(to: CGPoint(x: 809.5, y: 552.5))
        blackArrow.setStroke()
        cMuxLnPath.lineWidth = 1
        cMuxLnPath.stroke()
        
        
        //// CMuxArrow Drawing
        context.saveGState()
        context.translateBy(x: 356.25, y: 587.38)
        context.rotate(by: -90 * CGFloat.pi/180)
        
        let cMuxArrowPath = UIBezierPath()
        cMuxArrowPath.move(to: CGPoint(x: 0, y: 4))
        cMuxArrowPath.addLine(to: CGPoint(x: 10.31, y: 0))
        cMuxArrowPath.addLine(to: CGPoint(x: 10.31, y: 3))
        cMuxArrowPath.addLine(to: CGPoint(x: 10.31, y: 5))
        cMuxArrowPath.addLine(to: CGPoint(x: 10.31, y: 8))
        cMuxArrowPath.addLine(to: CGPoint(x: 0, y: 4))
        cMuxArrowPath.close()
        blackArrow.setFill()
        cMuxArrowPath.fill()
        blackArrow.setStroke()
        cMuxArrowPath.lineWidth = 1
        cMuxArrowPath.stroke()
        
        context.restoreGState()
        
        
        //// CMuxval Drawing
        let cMuxvalPath = UIBezierPath(rect: CGRect(x: 815.5, y: 540.5, width: 30, height: 24))
        noFillColor.setFill()
        cMuxvalPath.fill()
        black.setStroke()
        cMuxvalPath.lineWidth = 1
        cMuxvalPath.stroke()
        
        
        
        
        //// CSMuxLines
        //// CSMuxArrow Drawing
        let cSMuxArrowPath = UIBezierPath()
        cSMuxArrowPath.move(to: CGPoint(x: 704.97, y: 631.38))
        cSMuxArrowPath.addLine(to: CGPoint(x: 715.28, y: 627.38))
        cSMuxArrowPath.addLine(to: CGPoint(x: 715.28, y: 630.38))
        cSMuxArrowPath.addLine(to: CGPoint(x: 715.28, y: 632.38))
        cSMuxArrowPath.addLine(to: CGPoint(x: 715.28, y: 635.38))
        cSMuxArrowPath.addLine(to: CGPoint(x: 704.97, y: 631.38))
        cSMuxArrowPath.close()
        blackArrow.setFill()
        cSMuxArrowPath.fill()
        blackArrow.setStroke()
        cSMuxArrowPath.lineWidth = 1
        cSMuxArrowPath.stroke()
        
        
        //// CSMuxLine Drawing
        let cSMuxLinePath = UIBezierPath()
        cSMuxLinePath.move(to: CGPoint(x: 809.5, y: 631.5))
        cSMuxLinePath.addLine(to: CGPoint(x: 715.5, y: 631.5))
        blackArrow.setStroke()
        cSMuxLinePath.lineWidth = 1
        cSMuxLinePath.stroke()
        
        
        //// CSMuxToALULn Drawing
        let cSMuxToALULnPath = UIBezierPath()
        cSMuxToALULnPath.move(to: CGPoint(x: 651.5, y: 618.5))
        cSMuxToALULnPath.addLine(to: CGPoint(x: 651.5, y: 597.5))
        cSMuxToALULnPath.addLine(to: CGPoint(x: 600.5, y: 597.5))
        blackArrow.setStroke()
        cSMuxToALULnPath.lineWidth = 1
        cSMuxToALULnPath.stroke()
        
        
        //// CSMuxToALUArrow Drawing
        let cSMuxToALUArrowPath = UIBezierPath()
        cSMuxToALUArrowPath.move(to: CGPoint(x: 589.97, y: 597.38))
        cSMuxToALUArrowPath.addLine(to: CGPoint(x: 600.28, y: 593.38))
        cSMuxToALUArrowPath.addLine(to: CGPoint(x: 600.28, y: 596.38))
        cSMuxToALUArrowPath.addLine(to: CGPoint(x: 600.28, y: 598.38))
        cSMuxToALUArrowPath.addLine(to: CGPoint(x: 600.28, y: 601.38))
        cSMuxToALUArrowPath.addLine(to: CGPoint(x: 589.97, y: 597.38))
        cSMuxToALUArrowPath.close()
        blackArrow.setFill()
        cSMuxToALUArrowPath.fill()
        blackArrow.setStroke()
        cSMuxToALUArrowPath.lineWidth = 1
        cSMuxToALUArrowPath.stroke()
        
        
        //// CCkToCSMuxLn Drawing
        let cCkToCSMuxLnPath = UIBezierPath()
        cCkToCSMuxLnPath.move(to: CGPoint(x: 690, y: 726.5))
        cCkToCSMuxLnPath.addLine(to: CGPoint(x: 690, y: 714.5))
        cCkToCSMuxLnPath.addLine(to: CGPoint(x: 613, y: 714.5))
        cCkToCSMuxLnPath.addLine(to: CGPoint(x: 613, y: 648.5))
        blackArrow.setStroke()
        cCkToCSMuxLnPath.lineWidth = 1
        cCkToCSMuxLnPath.stroke()
        
        
        //// SCkToCSMuxLn Drawing
        let sCkToCSMuxLnPath = UIBezierPath()
        sCkToCSMuxLnPath.move(to: CGPoint(x: 690.5, y: 682.5))
        sCkToCSMuxLnPath.addLine(to: CGPoint(x: 690.5, y: 648.5))
        blackArrow.setStroke()
        sCkToCSMuxLnPath.lineWidth = 1
        sCkToCSMuxLnPath.stroke()
        
        
        //// SCkToCSMuxArrow Drawing
        context.saveGState()
        context.translateBy(x: 686.5, y: 656.88)
        context.rotate(by: -90 * CGFloat.pi/180)
        
        let sCkToCSMuxArrowPath = UIBezierPath()
        sCkToCSMuxArrowPath.move(to: CGPoint(x: 11.11, y: 4))
        sCkToCSMuxArrowPath.addLine(to: CGPoint(x: 1, y: 0))
        sCkToCSMuxArrowPath.addLine(to: CGPoint(x: 1, y: 3))
        sCkToCSMuxArrowPath.addLine(to: CGPoint(x: 1, y: 5))
        sCkToCSMuxArrowPath.addLine(to: CGPoint(x: 1, y: 8))
        sCkToCSMuxArrowPath.addLine(to: CGPoint(x: 11.11, y: 4))
        sCkToCSMuxArrowPath.close()
        blackArrow.setFill()
        sCkToCSMuxArrowPath.fill()
        blackArrow.setStroke()
        sCkToCSMuxArrowPath.lineWidth = 1
        sCkToCSMuxArrowPath.stroke()
        
        context.restoreGState()
        
        
        //// CCkToCSMuxArrow Drawing
        context.saveGState()
        context.translateBy(x: 609, y: 656.88)
        context.rotate(by: -90 * CGFloat.pi/180)
        
        let cCkToCSMuxArrowPath = UIBezierPath()
        cCkToCSMuxArrowPath.move(to: CGPoint(x: 11.11, y: 4))
        cCkToCSMuxArrowPath.addLine(to: CGPoint(x: 1, y: 0))
        cCkToCSMuxArrowPath.addLine(to: CGPoint(x: 1, y: 3))
        cCkToCSMuxArrowPath.addLine(to: CGPoint(x: 1, y: 5))
        cCkToCSMuxArrowPath.addLine(to: CGPoint(x: 1, y: 8))
        cCkToCSMuxArrowPath.addLine(to: CGPoint(x: 11.11, y: 4))
        cCkToCSMuxArrowPath.close()
        blackArrow.setFill()
        cCkToCSMuxArrowPath.fill()
        blackArrow.setStroke()
        cCkToCSMuxArrowPath.lineWidth = 1
        cCkToCSMuxArrowPath.stroke()
        
        context.restoreGState()
        
        
        //// CSMuxval Drawing
        let cSMuxvalPath = UIBezierPath(rect: CGRect(x: 815.5, y: 619.5, width: 30, height: 24))
        noFillColor.setFill()
        cSMuxvalPath.fill()
        black.setStroke()
        cSMuxvalPath.lineWidth = 1
        cSMuxvalPath.stroke()
        
        
        
        
        //// SCkLine
        //// SCkArrow Drawing
        let sCkArrowPath = UIBezierPath()
        sCkArrowPath.move(to: CGPoint(x: 704.97, y: 695.38))
        sCkArrowPath.addLine(to: CGPoint(x: 715.28, y: 691.38))
        sCkArrowPath.addLine(to: CGPoint(x: 715.28, y: 694.38))
        sCkArrowPath.addLine(to: CGPoint(x: 715.28, y: 696.38))
        sCkArrowPath.addLine(to: CGPoint(x: 715.28, y: 699.38))
        sCkArrowPath.addLine(to: CGPoint(x: 704.97, y: 695.38))
        sCkArrowPath.close()
        blackArrow.setFill()
        sCkArrowPath.fill()
        blackArrow.setStroke()
        sCkArrowPath.lineWidth = 1
        sCkArrowPath.stroke()
        
        
        //// SCkLn Drawing
        let sCkLnPath = UIBezierPath()
        sCkLnPath.move(to: CGPoint(x: 809.5, y: 695.5))
        sCkLnPath.addLine(to: CGPoint(x: 715.5, y: 695.5))
        blackArrow.setStroke()
        sCkLnPath.lineWidth = 1
        sCkLnPath.stroke()
        
        
        //// SCkval Drawing
        let sCkvalPath = UIBezierPath(roundedRect: CGRect(x: 815.5, y: 683.5, width: 24, height: 24), cornerRadius: 5)
        noFillColor.setFill()
        sCkvalPath.fill()
        black.setStroke()
        sCkvalPath.lineWidth = 1
        sCkvalPath.stroke()
        
        
        
        
        //// CCkLine
        //// CCkArrow Drawing
        let cCkArrowPath = UIBezierPath()
        cCkArrowPath.move(to: CGPoint(x: 704.97, y: 734.38))
        cCkArrowPath.addLine(to: CGPoint(x: 715.28, y: 730.38))
        cCkArrowPath.addLine(to: CGPoint(x: 715.28, y: 733.38))
        cCkArrowPath.addLine(to: CGPoint(x: 715.28, y: 735.38))
        cCkArrowPath.addLine(to: CGPoint(x: 715.28, y: 738.38))
        cCkArrowPath.addLine(to: CGPoint(x: 704.97, y: 734.38))
        cCkArrowPath.close()
        blackArrow.setFill()
        cCkArrowPath.fill()
        blackArrow.setStroke()
        cCkArrowPath.lineWidth = 1
        cCkArrowPath.stroke()
        
        
        //// CCkLn Drawing
        let cCkLnPath = UIBezierPath()
        cCkLnPath.move(to: CGPoint(x: 809.5, y: 734.5))
        cCkLnPath.addLine(to: CGPoint(x: 715.5, y: 734.5))
        blackArrow.setStroke()
        cCkLnPath.lineWidth = 1
        cCkLnPath.stroke()
        
        
        //// CCkval Drawing
        let cCkvalPath = UIBezierPath(roundedRect: CGRect(x: 815.5, y: 722.5, width: 24, height: 24), cornerRadius: 5)
        noFillColor.setFill()
        cCkvalPath.fill()
        black.setStroke()
        cCkvalPath.lineWidth = 1
        cCkvalPath.stroke()
        
        
        
        
        //// VCkLine
        //// VCkArrow Drawing
        let vCkArrowPath = UIBezierPath()
        vCkArrowPath.move(to: CGPoint(x: 704.97, y: 771.38))
        vCkArrowPath.addLine(to: CGPoint(x: 715.28, y: 767.38))
        vCkArrowPath.addLine(to: CGPoint(x: 715.28, y: 770.38))
        vCkArrowPath.addLine(to: CGPoint(x: 715.28, y: 772.38))
        vCkArrowPath.addLine(to: CGPoint(x: 715.28, y: 775.38))
        vCkArrowPath.addLine(to: CGPoint(x: 704.97, y: 771.38))
        vCkArrowPath.close()
        blackArrow.setFill()
        vCkArrowPath.fill()
        blackArrow.setStroke()
        vCkArrowPath.lineWidth = 1
        vCkArrowPath.stroke()
        
        
        //// VCkLn Drawing
        let vCkLnPath = UIBezierPath()
        vCkLnPath.move(to: CGPoint(x: 809.5, y: 771.5))
        vCkLnPath.addLine(to: CGPoint(x: 715.5, y: 771.5))
        blackArrow.setStroke()
        vCkLnPath.lineWidth = 1
        vCkLnPath.stroke()
        
        
        //// VCkval Drawing
        let vCkvalPath = UIBezierPath(roundedRect: CGRect(x: 815.5, y: 759.5, width: 24, height: 24), cornerRadius: 5)
        noFillColor.setFill()
        vCkvalPath.fill()
        black.setStroke()
        vCkvalPath.lineWidth = 1
        vCkvalPath.stroke()
        
        
        
        
        //// ZCkLine
        //// ZCkArrow Drawing
        let zCkArrowPath = UIBezierPath()
        zCkArrowPath.move(to: CGPoint(x: 704.97, y: 850.38))
        zCkArrowPath.addLine(to: CGPoint(x: 715.28, y: 846.38))
        zCkArrowPath.addLine(to: CGPoint(x: 715.28, y: 849.38))
        zCkArrowPath.addLine(to: CGPoint(x: 715.28, y: 851.38))
        zCkArrowPath.addLine(to: CGPoint(x: 715.28, y: 854.38))
        zCkArrowPath.addLine(to: CGPoint(x: 704.97, y: 850.38))
        zCkArrowPath.close()
        blackArrow.setFill()
        zCkArrowPath.fill()
        blackArrow.setStroke()
        zCkArrowPath.lineWidth = 1
        zCkArrowPath.stroke()
        
        
        //// ZCkLn Drawing
        let zCkLnPath = UIBezierPath()
        zCkLnPath.move(to: CGPoint(x: 809.5, y: 850.5))
        zCkLnPath.addLine(to: CGPoint(x: 715.5, y: 850.5))
        blackArrow.setStroke()
        zCkLnPath.lineWidth = 1
        zCkLnPath.stroke()
        
        
        //// ZCkval Drawing
        let zCkvalPath = UIBezierPath(roundedRect: CGRect(x: 815.5, y: 838.5, width: 24, height: 24), cornerRadius: 5)
        noFillColor.setFill()
        zCkvalPath.fill()
        black.setStroke()
        zCkvalPath.lineWidth = 1
        zCkvalPath.stroke()
        
        
        
        
        //// NCkLine
        //// NCkArrow Drawing
        let nCkArrowPath = UIBezierPath()
        nCkArrowPath.move(to: CGPoint(x: 704.97, y: 919.38))
        nCkArrowPath.addLine(to: CGPoint(x: 715.28, y: 915.38))
        nCkArrowPath.addLine(to: CGPoint(x: 715.28, y: 918.38))
        nCkArrowPath.addLine(to: CGPoint(x: 715.28, y: 920.38))
        nCkArrowPath.addLine(to: CGPoint(x: 715.28, y: 923.38))
        nCkArrowPath.addLine(to: CGPoint(x: 704.97, y: 919.38))
        nCkArrowPath.close()
        blackArrow.setFill()
        nCkArrowPath.fill()
        blackArrow.setStroke()
        nCkArrowPath.lineWidth = 1
        nCkArrowPath.stroke()
        
        
        //// NCkLn Drawing
        let nCkLnPath = UIBezierPath()
        nCkLnPath.move(to: CGPoint(x: 809.5, y: 919.5))
        nCkLnPath.addLine(to: CGPoint(x: 715.5, y: 919.5))
        blackArrow.setStroke()
        nCkLnPath.lineWidth = 1
        nCkLnPath.stroke()
        
        
        //// NCkval Drawing
        let nCkvalPath = UIBezierPath(roundedRect: CGRect(x: 815.5, y: 907.5, width: 24, height: 24), cornerRadius: 5)
        noFillColor.setFill()
        nCkvalPath.fill()
        black.setStroke()
        nCkvalPath.lineWidth = 1
        nCkvalPath.stroke()
        
        
        
        
        
        
        //// BComponents
        //// BBus Drawing
        let bBusPath = UIBezierPath()
        bBusPath.move(to: CGPoint(x: 592.5, y: 495.5))
        bBusPath.addLine(to: CGPoint(x: 602.5, y: 495.5))
        bBusPath.addLine(to: CGPoint(x: 585, y: 520.5))
        bBusPath.addLine(to: CGPoint(x: 567.5, y: 495.5))
        bBusPath.addLine(to: CGPoint(x: 577.5, y: 495.5))
        bBusPath.addLine(to: CGPoint(x: 577.5, y: 251.5))
        bBusPath.addLine(to: CGPoint(x: 360.5, y: 251.5))
        bBusPath.addLine(to: CGPoint(x: 360.5, y: 261.5))
        bBusPath.addLine(to: CGPoint(x: 335.5, y: 245.25))
        bBusPath.addLine(to: CGPoint(x: 360.5, y: 226.5))
        bBusPath.addLine(to: CGPoint(x: 360.5, y: 236.5))
        bBusPath.addLine(to: CGPoint(x: 577.5, y: 236.5))
        bBusPath.addLine(to: CGPoint(x: 577.5, y: 181.5))
        bBusPath.addLine(to: CGPoint(x: 592.5, y: 181.5))
        bBusPath.addLine(to: CGPoint(x: 592.5, y: 495.5))
        bBusPath.close()
        bBusPipeColor.setFill()
        bBusPath.fill()
        UIColor.black.setStroke()
        bBusPath.lineWidth = 1
        bBusPath.stroke()
        
        
        //// BBusText Drawing
        let bBusTextRect = CGRect(x: 603, y: 197, width: 49, height: 26)
        let bBusTextTextContent = "BBus"
        let bBusTextStyle = NSMutableParagraphStyle()
        bBusTextStyle.alignment = .left
        let bBusTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: bBusTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let bBusTextTextHeight: CGFloat = bBusTextTextContent.boundingRect(with: CGSize(width: bBusTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: bBusTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: bBusTextRect)
        bBusTextTextContent.draw(in: CGRect(x: bBusTextRect.minX, y: bBusTextRect.minY + (bBusTextRect.height - bBusTextTextHeight) / 2, width: bBusTextRect.width, height: bBusTextTextHeight), withAttributes: bBusTextFontAttributes)
        context.restoreGState()
        
        
        
        
        //// AComponents
        //// AMuxArrow Drawing
        let aMuxArrowPath = UIBezierPath()
        aMuxArrowPath.move(to: CGPoint(x: 474.5, y: 478.5))
        aMuxArrowPath.addLine(to: CGPoint(x: 474.5, y: 498.5))
        aMuxArrowPath.addLine(to: CGPoint(x: 484.5, y: 498.5))
        aMuxArrowPath.addLine(to: CGPoint(x: 466.5, y: 520.5))
        aMuxArrowPath.addLine(to: CGPoint(x: 449.5, y: 498.5))
        aMuxArrowPath.addLine(to: CGPoint(x: 459.5, y: 498.5))
        aMuxArrowPath.addLine(to: CGPoint(x: 459.67, y: 478.5))
        aMuxArrowPath.addLine(to: CGPoint(x: 474.5, y: 478.5))
        aMuxArrowPath.close()
        noFillColor.setFill()
        aMuxArrowPath.fill()
        UIColor.black.setStroke()
        aMuxArrowPath.lineWidth = 1
        aMuxArrowPath.stroke()
        
        
        //// Amux Drawing
        let amuxRect = CGRect(x: 417.5, y: 453.5, width: 100, height: 25)
        let amuxPath = UIBezierPath(rect: amuxRect)
        noFillColor.setFill()
        amuxPath.fill()
        UIColor.black.setStroke()
        amuxPath.lineWidth = 1
        amuxPath.stroke()
        let amuxTextContent = "AMux"
        let amuxStyle = NSMutableParagraphStyle()
        amuxStyle.alignment = .center
        let amuxFontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: amuxStyle,
            ] as [NSAttributedString.Key: Any]
        
        let amuxTextHeight: CGFloat = amuxTextContent.boundingRect(with: CGSize(width: amuxRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: amuxFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: amuxRect)
        amuxTextContent.draw(in: CGRect(x: amuxRect.minX, y: amuxRect.minY + (amuxRect.height - amuxTextHeight) / 2, width: amuxRect.width, height: amuxTextHeight), withAttributes: amuxFontAttributes)
        context.restoreGState()
        
        
        //// MDRCktoAMux Drawing
        let mDRCktoAMuxPath = UIBezierPath()
        mDRCktoAMuxPath.move(to: CGPoint(x: 445.5, y: 425.5))
        mDRCktoAMuxPath.addLine(to: CGPoint(x: 455.5, y: 425.5))
        mDRCktoAMuxPath.addLine(to: CGPoint(x: 438, y: 450.5))
        mDRCktoAMuxPath.addLine(to: CGPoint(x: 420.5, y: 425.5))
        mDRCktoAMuxPath.addLine(to: CGPoint(x: 430.5, y: 425.5))
        mDRCktoAMuxPath.addLine(to: CGPoint(x: 430.5, y: 410.5))
        mDRCktoAMuxPath.addLine(to: CGPoint(x: 331.5, y: 410.5))
        mDRCktoAMuxPath.addLine(to: CGPoint(x: 331.5, y: 395.5))
        mDRCktoAMuxPath.addLine(to: CGPoint(x: 430.5, y: 395.5))
        mDRCktoAMuxPath.addLine(to: CGPoint(x: 445.5, y: 395.5))
        mDRCktoAMuxPath.addLine(to: CGPoint(x: 445.5, y: 425.5))
        mDRCktoAMuxPath.close()
        addressBusColor.setFill()
        mDRCktoAMuxPath.fill()
        UIColor.black.setStroke()
        mDRCktoAMuxPath.lineWidth = 1
        mDRCktoAMuxPath.stroke()
        
        
        //// ABus Drawing
        let aBusPath = UIBezierPath()
        aBusPath.move(to: CGPoint(x: 506.5, y: 425.5))
        aBusPath.addLine(to: CGPoint(x: 516.5, y: 425.5))
        aBusPath.addLine(to: CGPoint(x: 499, y: 450.5))
        aBusPath.addLine(to: CGPoint(x: 481.5, y: 425.5))
        aBusPath.addLine(to: CGPoint(x: 491.5, y: 425.5))
        aBusPath.addLine(to: CGPoint(x: 491.5, y: 335.5))
        aBusPath.addLine(to: CGPoint(x: 359.5, y: 335.5))
        aBusPath.addLine(to: CGPoint(x: 359.5, y: 345.5))
        aBusPath.addLine(to: CGPoint(x: 334.5, y: 329.25))
        aBusPath.addLine(to: CGPoint(x: 359.5, y: 310.5))
        aBusPath.addLine(to: CGPoint(x: 359.5, y: 320.5))
        aBusPath.addLine(to: CGPoint(x: 491.5, y: 320.5))
        aBusPath.addLine(to: CGPoint(x: 491.5, y: 193.5))
        aBusPath.addLine(to: CGPoint(x: 506.5, y: 193.5))
        aBusPath.addLine(to: CGPoint(x: 506.5, y: 425.5))
        aBusPath.close()
        aBusPipeColor.setFill()
        aBusPath.fill()
        UIColor.black.setStroke()
        aBusPath.lineWidth = 1
        aBusPath.stroke()
        
        
        //// ABusText Drawing
        let aBusTextRect = CGRect(x: 515, y: 197, width: 49, height: 26)
        let aBusTextTextContent = "ABus"
        let aBusTextStyle = NSMutableParagraphStyle()
        aBusTextStyle.alignment = .left
        let aBusTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: aBusTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let aBusTextTextHeight: CGFloat = aBusTextTextContent.boundingRect(with: CGSize(width: aBusTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: aBusTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: aBusTextRect)
        aBusTextTextContent.draw(in: CGRect(x: aBusTextRect.minX, y: aBusTextRect.minY + (aBusTextRect.height - aBusTextTextHeight) / 2, width: aBusTextRect.width, height: aBusTextTextHeight), withAttributes: aBusTextFontAttributes)
        context.restoreGState()
        
        
        
        
        //// SystemBus
        //// BusMDRMux Drawing
        let busMDRMuxPath = UIBezierPath()
        busMDRMuxPath.move(to: CGPoint(x: 265.34, y: 495.5))
        busMDRMuxPath.addLine(to: CGPoint(x: 274.5, y: 495.5))
        busMDRMuxPath.addLine(to: CGPoint(x: 256.98, y: 470.5))
        busMDRMuxPath.addLine(to: CGPoint(x: 239.45, y: 495.5))
        busMDRMuxPath.addLine(to: CGPoint(x: 248.61, y: 495.5))
        busMDRMuxPath.addLine(to: CGPoint(x: 248.61, y: 505.5))
        busMDRMuxPath.addLine(to: CGPoint(x: 112.5, y: 505.5))
        busMDRMuxPath.addLine(to: CGPoint(x: 112.5, y: 520.5))
        busMDRMuxPath.addLine(to: CGPoint(x: 248.61, y: 520.5))
        busMDRMuxPath.addLine(to: CGPoint(x: 265.34, y: 520.5))
        busMDRMuxPath.addLine(to: CGPoint(x: 265.34, y: 495.5))
        busMDRMuxPath.close()
        dataBusColor.setFill()
        busMDRMuxPath.fill()
        UIColor.black.setStroke()
        busMDRMuxPath.lineWidth = 1
        busMDRMuxPath.stroke()
        
        
        //// DataArrow Drawing
        let dataArrowPath = UIBezierPath()
        dataArrowPath.move(to: CGPoint(x: 56.53, y: 542.5))
        dataArrowPath.addLine(to: CGPoint(x: 47.75, y: 542.5))
        dataArrowPath.addLine(to: CGPoint(x: 47.75, y: 550.5))
        dataArrowPath.addLine(to: CGPoint(x: 31.5, y: 535.5))
        dataArrowPath.addLine(to: CGPoint(x: 47.75, y: 519.5))
        dataArrowPath.addLine(to: CGPoint(x: 47.75, y: 527.5))
        dataArrowPath.move(to: CGPoint(x: 47.75, y: 527.5))
        dataArrowPath.addLine(to: CGPoint(x: 56.53, y: 527.5))
        dataArrowPath.addLine(to: CGPoint(x: 65.25, y: 527.5))
        dataArrowPath.addLine(to: CGPoint(x: 65.25, y: 519.5))
        dataArrowPath.addLine(to: CGPoint(x: 81.5, y: 534.5))
        dataArrowPath.addLine(to: CGPoint(x: 65.25, y: 550.5))
        dataArrowPath.addLine(to: CGPoint(x: 65.25, y: 542.5))
        dataArrowPath.addLine(to: CGPoint(x: 56.53, y: 542.5))
        dataBusColor.setFill()
        dataArrowPath.fill()
        UIColor.black.setStroke()
        dataArrowPath.lineWidth = 1
        dataArrowPath.stroke()
        
        
        //// AddrArrow Drawing
        let addrArrowPath = UIBezierPath()
        addrArrowPath.move(to: CGPoint(x: 83.5, y: 484.5))
        addrArrowPath.addLine(to: CGPoint(x: 55.28, y: 484.5))
        addrArrowPath.addLine(to: CGPoint(x: 55.33, y: 490.5))
        addrArrowPath.addLine(to: CGPoint(x: 28.5, y: 469.5))
        addrArrowPath.addLine(to: CGPoint(x: 55.33, y: 449.5))
        addrArrowPath.addLine(to: CGPoint(x: 55.28, y: 455.5))
        addrArrowPath.addLine(to: CGPoint(x: 83.5, y: 455.5))
        addrArrowPath.addLine(to: CGPoint(x: 83.5, y: 484.5))
        addrArrowPath.close()
        addressBusColor.setFill()
        addrArrowPath.fill()
        UIColor.black.setStroke()
        addrArrowPath.lineWidth = 1
        addrArrowPath.stroke()
        
        
        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(rect: CGRect(x: 83, y: 257.62, width: 29, height: 752.12))
        addressBusColor.setFill()
        rectanglePath.fill()
        UIColor.black.setStroke()
        rectanglePath.lineWidth = 1
        rectanglePath.stroke()
        
        
        //// SystemBus2 Drawing
        let systemBus2Path = UIBezierPath(rect: CGRect(x: 112, y: 390.5, width: 15.5, height: 619.24))
        dataBusColor.setFill()
        systemBus2Path.fill()
        UIColor.black.setStroke()
        systemBus2Path.lineWidth = 1
        systemBus2Path.stroke()
        
        
        //// SystemBusText Drawing
        context.saveGState()
        context.translateBy(x: 49, y: 391)
        context.rotate(by: -90 * CGFloat.pi/180)
        
        let systemBusTextRect = CGRect(x: 0, y: 0, width: 98, height: 34)
        let systemBusTextTextContent = "System Bus"
        let systemBusTextStyle = NSMutableParagraphStyle()
        systemBusTextStyle.alignment = .left
        let systemBusTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: systemBusTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let systemBusTextTextHeight: CGFloat = systemBusTextTextContent.boundingRect(with: CGSize(width: systemBusTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: systemBusTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: systemBusTextRect)
        systemBusTextTextContent.draw(in: CGRect(x: systemBusTextRect.minX, y: systemBusTextRect.minY + (systemBusTextRect.height - systemBusTextTextHeight) / 2, width: systemBusTextRect.width, height: systemBusTextTextHeight), withAttributes: systemBusTextFontAttributes)
        context.restoreGState()
        
        context.restoreGState()
        
        
        //// AddrArrowText Drawing
        let addrArrowTextRect = CGRect(x: 39, y: 431, width: 42, height: 18)
        let addrArrowTextTextContent = "Addr"
        let addrArrowTextStyle = NSMutableParagraphStyle()
        addrArrowTextStyle.alignment = .left
        let addrArrowTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: addrArrowTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let addrArrowTextTextHeight: CGFloat = addrArrowTextTextContent.boundingRect(with: CGSize(width: addrArrowTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: addrArrowTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: addrArrowTextRect)
        addrArrowTextTextContent.draw(in: CGRect(x: addrArrowTextRect.minX, y: addrArrowTextRect.minY + (addrArrowTextRect.height - addrArrowTextTextHeight) / 2, width: addrArrowTextRect.width, height: addrArrowTextTextHeight), withAttributes: addrArrowTextFontAttributes)
        context.restoreGState()
        
        
        //// DataArrowText Drawing
        let dataArrowTextRect = CGRect(x: 39, y: 553, width: 42, height: 18)
        let dataArrowTextTextContent = "Data"
        let dataArrowTextStyle = NSMutableParagraphStyle()
        dataArrowTextStyle.alignment = .left
        let dataArrowTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: dataArrowTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let dataArrowTextTextHeight: CGFloat = dataArrowTextTextContent.boundingRect(with: CGSize(width: dataArrowTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: dataArrowTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: dataArrowTextRect)
        dataArrowTextTextContent.draw(in: CGRect(x: dataArrowTextRect.minX, y: dataArrowTextRect.minY + (dataArrowTextRect.height - dataArrowTextTextHeight) / 2, width: dataArrowTextRect.width, height: dataArrowTextTextHeight), withAttributes: dataArrowTextFontAttributes)
        context.restoreGState()
        
        
        
        
        //// MARComponents
        //// MARArrow Drawing
        let mARArrowPath = UIBezierPath()
        mARArrowPath.move(to: CGPoint(x: 289.59, y: 258))
        mARArrowPath.addCurve(to: CGPoint(x: 289.59, y: 287.87), controlPoint1: CGPoint(x: 289.59, y: 258), controlPoint2: CGPoint(x: 289.59, y: 284.94))
        mARArrowPath.addCurve(to: CGPoint(x: 289.59, y: 288.13), controlPoint1: CGPoint(x: 289.59, y: 288.04), controlPoint2: CGPoint(x: 289.59, y: 288.13))
        mARArrowPath.addCurve(to: CGPoint(x: 145.59, y: 288.13), controlPoint1: CGPoint(x: 289.59, y: 288.59), controlPoint2: CGPoint(x: 145.59, y: 288.13))
        mARArrowPath.addLine(to: CGPoint(x: 289.59, y: 288.13))
        mARArrowPath.addLine(to: CGPoint(x: 289.59, y: 318))
        mARArrowPath.addLine(to: CGPoint(x: 274.59, y: 318))
        mARArrowPath.addLine(to: CGPoint(x: 274.59, y: 302.87))
        mARArrowPath.addLine(to: CGPoint(x: 145.59, y: 302.87))
        mARArrowPath.addLine(to: CGPoint(x: 145.59, y: 312.87))
        mARArrowPath.addCurve(to: CGPoint(x: 121.74, y: 287.87), controlPoint1: CGPoint(x: 145.59, y: 312.87), controlPoint2: CGPoint(x: 121.58, y: 287.87))
        mARArrowPath.addCurve(to: CGPoint(x: 137.46, y: 271.57), controlPoint1: CGPoint(x: 123.23, y: 286.33), controlPoint2: CGPoint(x: 131.15, y: 278.12))
        mARArrowPath.addCurve(to: CGPoint(x: 145.59, y: 263.13), controlPoint1: CGPoint(x: 141.93, y: 266.93), controlPoint2: CGPoint(x: 145.59, y: 263.13))
        mARArrowPath.addLine(to: CGPoint(x: 145.59, y: 273.13))
        mARArrowPath.addLine(to: CGPoint(x: 274.59, y: 273.13))
        mARArrowPath.addLine(to: CGPoint(x: 274.59, y: 258))
        mARArrowPath.addLine(to: CGPoint(x: 289.59, y: 258))
        mARArrowPath.close()
        addressBusColor.setFill()
        mARArrowPath.fill()
        UIColor.black.setStroke()
        mARArrowPath.lineWidth = 1
        mARArrowPath.stroke()
        
        
        //// MARB Drawing
        let mARBRect = CGRect(x: 231.5, y: 232.5, width: 100, height: 25)
        let mARBPath = UIBezierPath(rect: mARBRect)
        registerBankColor.setFill()
        mARBPath.fill()
        UIColor.black.setStroke()
        mARBPath.lineWidth = 1
        mARBPath.stroke()
        let mARBTextContent = "0x00"
        let mARBStyle = NSMutableParagraphStyle()
        mARBStyle.alignment = .center
        let mARBFontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: mARBStyle,
            ] as [NSAttributedString.Key: Any]
        
        let mARBTextHeight: CGFloat = mARBTextContent.boundingRect(with: CGSize(width: mARBRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mARBFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mARBRect)
        mARBTextContent.draw(in: CGRect(x: mARBRect.minX, y: mARBRect.minY + (mARBRect.height - mARBTextHeight) / 2, width: mARBRect.width, height: mARBTextHeight), withAttributes: mARBFontAttributes)
        context.restoreGState()
        
        
        //// MARBLabel Drawing
        let mARBLabelRect = CGRect(x: 180, y: 239, width: 51, height: 15)
        let mARBLabelTextContent = "MARB"
        let mARBLabelStyle = NSMutableParagraphStyle()
        mARBLabelStyle.alignment = .center
        let mARBLabelFontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.systemFontSize),
            .foregroundColor: labelBlack,
            .paragraphStyle: mARBLabelStyle,
            ] as [NSAttributedString.Key: Any]
        
        let mARBLabelTextHeight: CGFloat = mARBLabelTextContent.boundingRect(with: CGSize(width: mARBLabelRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mARBLabelFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mARBLabelRect)
        mARBLabelTextContent.draw(in: CGRect(x: mARBLabelRect.minX, y: mARBLabelRect.minY + (mARBLabelRect.height - mARBLabelTextHeight) / 2, width: mARBLabelRect.width, height: mARBLabelTextHeight), withAttributes: mARBLabelFontAttributes)
        context.restoreGState()
        
        
        //// MARB 2 Drawing
        let mARB2Rect = CGRect(x: 231.5, y: 317.5, width: 100, height: 25)
        let mARB2Path = UIBezierPath(rect: mARB2Rect)
        registerBankColor.setFill()
        mARB2Path.fill()
        UIColor.black.setStroke()
        mARB2Path.lineWidth = 1
        mARB2Path.stroke()
        let mARB2TextContent = "0x00"
        let mARB2Style = NSMutableParagraphStyle()
        mARB2Style.alignment = .center
        let mARB2FontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: mARB2Style,
            ] as [NSAttributedString.Key: Any]
        
        let mARB2TextHeight: CGFloat = mARB2TextContent.boundingRect(with: CGSize(width: mARB2Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mARB2FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mARB2Rect)
        mARB2TextContent.draw(in: CGRect(x: mARB2Rect.minX, y: mARB2Rect.minY + (mARB2Rect.height - mARB2TextHeight) / 2, width: mARB2Rect.width, height: mARB2TextHeight), withAttributes: mARB2FontAttributes)
        context.restoreGState()
        
        
        //// MARALabel Drawing
        let mARALabelRect = CGRect(x: 180, y: 323, width: 51, height: 15)
        let mARALabelTextContent = "MARA"
        let mARALabelStyle = NSMutableParagraphStyle()
        mARALabelStyle.alignment = .center
        let mARALabelFontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.systemFontSize),
            .foregroundColor: labelBlack,
            .paragraphStyle: mARALabelStyle,
            ] as [NSAttributedString.Key: Any]
        
        let mARALabelTextHeight: CGFloat = mARALabelTextContent.boundingRect(with: CGSize(width: mARALabelRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mARALabelFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mARALabelRect)
        mARALabelTextContent.draw(in: CGRect(x: mARALabelRect.minX, y: mARALabelRect.minY + (mARALabelRect.height - mARALabelTextHeight) / 2, width: mARALabelRect.width, height: mARALabelTextHeight), withAttributes: mARALabelFontAttributes)
        context.restoreGState()
        
        
        
        
        //// MDRComponents
        //// MDR Drawing
        let mDRRect = CGRect(x: 231.5, y: 391.5, width: 100, height: 25)
        let mDRPath = UIBezierPath(rect: mDRRect)
        registerBankColor.setFill()
        mDRPath.fill()
        UIColor.black.setStroke()
        mDRPath.lineWidth = 1
        mDRPath.stroke()
        let mDRTextContent = "0x00"
        let mDRStyle = NSMutableParagraphStyle()
        mDRStyle.alignment = .center
        let mDRFontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: mDRStyle,
            ] as [NSAttributedString.Key: Any]
        
        let mDRTextHeight: CGFloat = mDRTextContent.boundingRect(with: CGSize(width: mDRRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mDRFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mDRRect)
        mDRTextContent.draw(in: CGRect(x: mDRRect.minX, y: mDRRect.minY + (mDRRect.height - mDRTextHeight) / 2, width: mDRRect.width, height: mDRTextHeight), withAttributes: mDRFontAttributes)
        context.restoreGState()
        
        
        //// MemWrite Drawing
        let memWritePath = UIBezierPath()
        memWritePath.move(to: CGPoint(x: 231.5, y: 411.5))
        memWritePath.addLine(to: CGPoint(x: 156.29, y: 411.5))
        memWritePath.addLine(to: CGPoint(x: 156.29, y: 421.5))
        memWritePath.addLine(to: CGPoint(x: 128.5, y: 404.5))
        memWritePath.addLine(to: CGPoint(x: 156.29, y: 386.5))
        memWritePath.addLine(to: CGPoint(x: 156.29, y: 396.5))
        memWritePath.addLine(to: CGPoint(x: 231.5, y: 396.5))
        memWritePath.addLine(to: CGPoint(x: 231.5, y: 411.5))
        memWritePath.close()
        mDRColor.setFill()
        memWritePath.fill()
        UIColor.black.setStroke()
        memWritePath.lineWidth = 1
        memWritePath.stroke()
        
        
        //// MDRMux Drawing
        let mDRMuxRect = CGRect(x: 231.5, y: 443.5, width: 100, height: 25)
        let mDRMuxPath = UIBezierPath(rect: mDRMuxRect)
        noFillColor.setFill()
        mDRMuxPath.fill()
        UIColor.black.setStroke()
        mDRMuxPath.lineWidth = 1
        mDRMuxPath.stroke()
        let mDRMuxTextContent = "MDRMux"
        let mDRMuxStyle = NSMutableParagraphStyle()
        mDRMuxStyle.alignment = .center
        let mDRMuxFontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: mDRMuxStyle,
            ] as [NSAttributedString.Key: Any]
        
        let mDRMuxTextHeight: CGFloat = mDRMuxTextContent.boundingRect(with: CGSize(width: mDRMuxRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mDRMuxFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mDRMuxRect)
        mDRMuxTextContent.draw(in: CGRect(x: mDRMuxRect.minX, y: mDRMuxRect.minY + (mDRMuxRect.height - mDRMuxTextHeight) / 2, width: mDRMuxRect.width, height: mDRMuxTextHeight), withAttributes: mDRMuxFontAttributes)
        context.restoreGState()
        
        
        //// MDRMuxArrow Drawing
        context.saveGState()
        context.translateBy(x: 293.5, y: 418.5)
        context.rotate(by: 90 * CGFloat.pi/180)
        
        let mDRMuxArrowPath = UIBezierPath()
        mDRMuxArrowPath.move(to: CGPoint(x: 25, y: 20.14))
        mDRMuxArrowPath.addLine(to: CGPoint(x: 12.1, y: 20.14))
        mDRMuxArrowPath.addLine(to: CGPoint(x: 12.1, y: 27))
        mDRMuxArrowPath.addLine(to: CGPoint(x: 0, y: 12))
        mDRMuxArrowPath.addLine(to: CGPoint(x: 12.1, y: -3))
        mDRMuxArrowPath.addLine(to: CGPoint(x: 12.1, y: 3.86))
        mDRMuxArrowPath.addLine(to: CGPoint(x: 25, y: 3.86))
        mDRMuxArrowPath.addLine(to: CGPoint(x: 25, y: 20.14))
        mDRMuxArrowPath.close()
        noFillColor.setFill()
        mDRMuxArrowPath.fill()
        UIColor.black.setStroke()
        mDRMuxArrowPath.lineWidth = 1
        mDRMuxArrowPath.stroke()
        
        context.restoreGState()
        
        
        
        
        //// CComponents
        //// Zeros Drawing
        let zerosRect = CGRect(x: 409, y: 826, width: 11, height: 106)
        let zerosTextContent = "0\n0\n0\n0\n"
        let zerosStyle = NSMutableParagraphStyle()
        zerosStyle.alignment = .left
        let zerosFontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: zerosStyle,
            ] as [NSAttributedString.Key: Any]
        
        let zerosTextHeight: CGFloat = zerosTextContent.boundingRect(with: CGSize(width: zerosRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: zerosFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: zerosRect)
        zerosTextContent.draw(in: CGRect(x: zerosRect.minX, y: zerosRect.minY + (zerosRect.height - zerosTextHeight) / 2, width: zerosRect.width, height: zerosTextHeight), withAttributes: zerosFontAttributes)
        context.restoreGState()
        
        
        //// CBusText Drawing
        let cBusTextRect = CGRect(x: 412, y: 197, width: 49, height: 26)
        let cBusTextTextContent = "CBus"
        let cBusTextStyle = NSMutableParagraphStyle()
        cBusTextStyle.alignment = .left
        let cBusTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: UIColor.black,
            .paragraphStyle: cBusTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let cBusTextTextHeight: CGFloat = cBusTextTextContent.boundingRect(with: CGSize(width: cBusTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: cBusTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: cBusTextRect)
        cBusTextTextContent.draw(in: CGRect(x: cBusTextRect.minX, y: cBusTextRect.minY + (cBusTextRect.height - cBusTextTextHeight) / 2, width: cBusTextRect.width, height: cBusTextTextHeight), withAttributes: cBusTextFontAttributes)
        context.restoreGState()
        
        
        //// CBus Drawing
        let cBusPath = UIBezierPath()
        cBusPath.move(to: CGPoint(x: 392, y: 200.5))
        cBusPath.addCurve(to: CGPoint(x: 409.5, y: 225.5), controlPoint1: CGPoint(x: 392, y: 200.5), controlPoint2: CGPoint(x: 409.5, y: 225.5))
        cBusPath.addLine(to: CGPoint(x: 399.5, y: 225.5))
        cBusPath.addLine(to: CGPoint(x: 399.5, y: 589.5))
        cBusPath.addLine(to: CGPoint(x: 384.67, y: 589.5))
        cBusPath.addLine(to: CGPoint(x: 399.5, y: 589.5))
        cBusPath.addLine(to: CGPoint(x: 384.67, y: 589.5))
        cBusPath.addCurve(to: CGPoint(x: 384.66, y: 543.42), controlPoint1: CGPoint(x: 384.67, y: 589.5), controlPoint2: CGPoint(x: 384.66, y: 559.77))
        cBusPath.addCurve(to: CGPoint(x: 384.65, y: 521.5), controlPoint1: CGPoint(x: 384.65, y: 536.54), controlPoint2: CGPoint(x: 384.65, y: 530.49))
        cBusPath.addLine(to: CGPoint(x: 299.5, y: 521.5))
        cBusPath.addLine(to: CGPoint(x: 299.5, y: 496.5))
        cBusPath.addLine(to: CGPoint(x: 289.5, y: 496.5))
        cBusPath.addLine(to: CGPoint(x: 307, y: 471.5))
        cBusPath.addLine(to: CGPoint(x: 324.5, y: 496.5))
        cBusPath.addLine(to: CGPoint(x: 314.5, y: 496.5))
        cBusPath.addLine(to: CGPoint(x: 314.5, y: 506.5))
        cBusPath.addLine(to: CGPoint(x: 384.64, y: 506.5))
        cBusPath.addCurve(to: CGPoint(x: 384.5, y: 225.5), controlPoint1: CGPoint(x: 384.59, y: 398.18), controlPoint2: CGPoint(x: 384.5, y: 225.5))
        cBusPath.addLine(to: CGPoint(x: 374.5, y: 225.5))
        cBusPath.addLine(to: CGPoint(x: 392, y: 200.5))
        cBusPath.addLine(to: CGPoint(x: 392, y: 200.5))
        cBusPath.close()
        cBusColor.setFill()
        cBusPath.fill()
        UIColor.black.setStroke()
        cBusPath.lineWidth = 1
        cBusPath.stroke()
        
        
        //// CMux Drawing
        let cMuxRect = CGRect(x: 342.5, y: 589.5, width: 100, height: 25)
        let cMuxPath = UIBezierPath(rect: cMuxRect)
        noFillColor.setFill()
        cMuxPath.fill()
        UIColor.black.setStroke()
        cMuxPath.lineWidth = 1
        cMuxPath.stroke()
        let cMuxTextContent = "CMux"
        let cMuxStyle = NSMutableParagraphStyle()
        cMuxStyle.alignment = .center
        let cMuxFontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: cMuxStyle,
            ] as [NSAttributedString.Key: Any]
        
        let cMuxTextHeight: CGFloat = cMuxTextContent.boundingRect(with: CGSize(width: cMuxRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: cMuxFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: cMuxRect)
        cMuxTextContent.draw(in: CGRect(x: cMuxRect.minX, y: cMuxRect.minY + (cMuxRect.height - cMuxTextHeight) / 2, width: cMuxRect.width, height: cMuxTextHeight), withAttributes: cMuxFontAttributes)
        context.restoreGState()
        
        
        //// CmuxBus Drawing
        let cmuxBusPath = UIBezierPath()
        cmuxBusPath.move(to: CGPoint(x: 354, y: 641.75))
        cmuxBusPath.addLine(to: CGPoint(x: 344, y: 641.75))
        cmuxBusPath.addLine(to: CGPoint(x: 361.5, y: 616.75))
        cmuxBusPath.addLine(to: CGPoint(x: 379, y: 641.75))
        cmuxBusPath.addLine(to: CGPoint(x: 369, y: 641.75))
        cmuxBusPath.addLine(to: CGPoint(x: 369, y: 821.75))
        cmuxBusPath.addLine(to: CGPoint(x: 407, y: 821.75))
        cmuxBusPath.addLine(to: CGPoint(x: 407, y: 740.27))
        cmuxBusPath.addLine(to: CGPoint(x: 407, y: 912.88))
        cmuxBusPath.addLine(to: CGPoint(x: 407, y: 836.75))
        cmuxBusPath.addLine(to: CGPoint(x: 369, y: 836.75))
        cmuxBusPath.addLine(to: CGPoint(x: 354, y: 836.75))
        cmuxBusPath.addLine(to: CGPoint(x: 354, y: 641.75))
        cmuxBusPath.close()
        addressBusColor.setFill()
        cmuxBusPath.fill()
        UIColor.black.setStroke()
        cmuxBusPath.lineWidth = 1
        cmuxBusPath.stroke()
        
        
        
        
        //// ALUComponents
        //// ALUtoCMux Drawing
        let aLUtoCMuxPath = UIBezierPath()
        aLUtoCMuxPath.move(to: CGPoint(x: 422.5, y: 617.5))
        aLUtoCMuxPath.addCurve(to: CGPoint(x: 440, y: 642.5), controlPoint1: CGPoint(x: 422.5, y: 617.5), controlPoint2: CGPoint(x: 440, y: 642.5))
        aLUtoCMuxPath.addLine(to: CGPoint(x: 430, y: 642.5))
        aLUtoCMuxPath.addLine(to: CGPoint(x: 430, y: 656.5))
        aLUtoCMuxPath.addLine(to: CGPoint(x: 478, y: 656.5))
        aLUtoCMuxPath.addCurve(to: CGPoint(x: 478, y: 602), controlPoint1: CGPoint(x: 478, y: 650.17), controlPoint2: CGPoint(x: 478, y: 602))
        aLUtoCMuxPath.addLine(to: CGPoint(x: 493, y: 602))
        aLUtoCMuxPath.addLine(to: CGPoint(x: 493, y: 671.5))
        aLUtoCMuxPath.addLine(to: CGPoint(x: 415, y: 671.5))
        aLUtoCMuxPath.addLine(to: CGPoint(x: 415, y: 642.5))
        aLUtoCMuxPath.addLine(to: CGPoint(x: 405, y: 642.5))
        aLUtoCMuxPath.addLine(to: CGPoint(x: 422.5, y: 617.5))
        aLUtoCMuxPath.addLine(to: CGPoint(x: 422.5, y: 617.5))
        aLUtoCMuxPath.close()
        cBusColor.setFill()
        aLUtoCMuxPath.fill()
        UIColor.black.setStroke()
        aLUtoCMuxPath.lineWidth = 1
        aLUtoCMuxPath.stroke()
        
        
        //// ALU Drawing
        let aLUPath = UIBezierPath()
        aLUPath.move(to: CGPoint(x: 438.5, y: 521.5))
        aLUPath.addLine(to: CGPoint(x: 497.5, y: 521.5))
        aLUPath.addLine(to: CGPoint(x: 507.5, y: 541.5))
        aLUPath.addLine(to: CGPoint(x: 544.14, y: 541.5))
        aLUPath.addLine(to: CGPoint(x: 554.5, y: 521.5))
        aLUPath.addLine(to: CGPoint(x: 613.5, y: 521.5))
        aLUPath.addLine(to: CGPoint(x: 583.5, y: 605.5))
        aLUPath.addLine(to: CGPoint(x: 468.5, y: 605.5))
        aLUPath.addLine(to: CGPoint(x: 438.5, y: 521.5))
        aLUPath.close()
        cBusColor.setFill()
        aLUPath.fill()
        UIColor.black.setStroke()
        aLUPath.lineWidth = 1
        aLUPath.stroke()
        
        
        //// ALUText Drawing
        let aLUTextRect = CGRect(x: 494, y: 575, width: 65, height: 15)
        let aLUTextTextContent = "ALU"
        let aLUTextStyle = NSMutableParagraphStyle()
        aLUTextStyle.alignment = .center
        let aLUTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.systemFontSize),
            .foregroundColor: labelBlack,
            .paragraphStyle: aLUTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let aLUTextTextHeight: CGFloat = aLUTextTextContent.boundingRect(with: CGSize(width: aLUTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: aLUTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: aLUTextRect)
        aLUTextTextContent.draw(in: CGRect(x: aLUTextRect.minX, y: aLUTextRect.minY + (aLUTextRect.height - aLUTextTextHeight) / 2, width: aLUTextRect.width, height: aLUTextTextHeight), withAttributes: aLUTextFontAttributes)
        context.restoreGState()
        
        
        //// ALUInstruction Drawing
        let aLUInstructionRect = CGRect(x: 494, y: 550, width: 65, height: 15)
        let aLUInstructionTextContent = "   "
        let aLUInstructionStyle = NSMutableParagraphStyle()
        aLUInstructionStyle.alignment = .center
        let aLUInstructionFontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.systemFontSize),
            .foregroundColor: labelBlack,
            .paragraphStyle: aLUInstructionStyle,
            ] as [NSAttributedString.Key: Any]
        
        let aLUInstructionTextHeight: CGFloat = aLUInstructionTextContent.boundingRect(with: CGSize(width: aLUInstructionRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: aLUInstructionFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: aLUInstructionRect)
        aLUInstructionTextContent.draw(in: CGRect(x: aLUInstructionRect.minX, y: aLUInstructionRect.minY + (aLUInstructionRect.height - aLUInstructionTextHeight) / 2, width: aLUInstructionRect.width, height: aLUInstructionTextHeight), withAttributes: aLUInstructionFontAttributes)
        context.restoreGState()
        
        
        
        
        //// CSMuxComponents
        //// CSMux Drawing
        let cSMuxRect = CGRect(x: 601.5, y: 618.5, width: 100, height: 25)
        let cSMuxPath = UIBezierPath(rect: cSMuxRect)
        noFillColor.setFill()
        cSMuxPath.fill()
        UIColor.black.setStroke()
        cSMuxPath.lineWidth = 1
        cSMuxPath.stroke()
        let cSMuxTextContent = "CSMux"
        let cSMuxStyle = NSMutableParagraphStyle()
        cSMuxStyle.alignment = .center
        let cSMuxFontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: cSMuxStyle,
            ] as [NSAttributedString.Key: Any]
        
        let cSMuxTextHeight: CGFloat = cSMuxTextContent.boundingRect(with: CGSize(width: cSMuxRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: cSMuxFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: cSMuxRect)
        cSMuxTextContent.draw(in: CGRect(x: cSMuxRect.minX, y: cSMuxRect.minY + (cSMuxRect.height - cSMuxTextHeight) / 2, width: cSMuxRect.width, height: cSMuxTextHeight), withAttributes: cSMuxFontAttributes)
        context.restoreGState()
        
        
        
        
        //// Bits
        //// Rectangle 2 Drawing
        let rectangle2Rect = CGRect(x: 677, y: 683, width: 25, height: 25)
        let rectangle2Path = UIBezierPath(rect: rectangle2Rect)
        registerBankColor.setFill()
        rectangle2Path.fill()
        black.setStroke()
        rectangle2Path.lineWidth = 1
        rectangle2Path.stroke()
        let rectangle2TextContent = "0"
        let rectangle2Style = NSMutableParagraphStyle()
        rectangle2Style.alignment = .center
        let rectangle2FontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: rectangle2Style,
            ] as [NSAttributedString.Key: Any]
        
        let rectangle2TextHeight: CGFloat = rectangle2TextContent.boundingRect(with: CGSize(width: rectangle2Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: rectangle2FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: rectangle2Rect)
        rectangle2TextContent.draw(in: CGRect(x: rectangle2Rect.minX, y: rectangle2Rect.minY + (rectangle2Rect.height - rectangle2TextHeight) / 2, width: rectangle2Rect.width, height: rectangle2TextHeight), withAttributes: rectangle2FontAttributes)
        context.restoreGState()
        
        
        //// Rectangle 3 Drawing
        let rectangle3Rect = CGRect(x: 677.5, y: 721.5, width: 25, height: 25)
        let rectangle3Path = UIBezierPath(rect: rectangle3Rect)
        registerBankColor.setFill()
        rectangle3Path.fill()
        black.setStroke()
        rectangle3Path.lineWidth = 1
        rectangle3Path.stroke()
        let rectangle3TextContent = "0"
        let rectangle3Style = NSMutableParagraphStyle()
        rectangle3Style.alignment = .center
        let rectangle3FontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: rectangle3Style,
            ] as [NSAttributedString.Key: Any]
        
        let rectangle3TextHeight: CGFloat = rectangle3TextContent.boundingRect(with: CGSize(width: rectangle3Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: rectangle3FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: rectangle3Rect)
        rectangle3TextContent.draw(in: CGRect(x: rectangle3Rect.minX, y: rectangle3Rect.minY + (rectangle3Rect.height - rectangle3TextHeight) / 2, width: rectangle3Rect.width, height: rectangle3TextHeight), withAttributes: rectangle3FontAttributes)
        context.restoreGState()
        
        
        //// Rectangle 4 Drawing
        let rectangle4Rect = CGRect(x: 677, y: 759, width: 25, height: 25)
        let rectangle4Path = UIBezierPath(rect: rectangle4Rect)
        registerBankColor.setFill()
        rectangle4Path.fill()
        black.setStroke()
        rectangle4Path.lineWidth = 1
        rectangle4Path.stroke()
        let rectangle4TextContent = "0"
        let rectangle4Style = NSMutableParagraphStyle()
        rectangle4Style.alignment = .center
        let rectangle4FontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: rectangle4Style,
            ] as [NSAttributedString.Key: Any]
        
        let rectangle4TextHeight: CGFloat = rectangle4TextContent.boundingRect(with: CGSize(width: rectangle4Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: rectangle4FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: rectangle4Rect)
        rectangle4TextContent.draw(in: CGRect(x: rectangle4Rect.minX, y: rectangle4Rect.minY + (rectangle4Rect.height - rectangle4TextHeight) / 2, width: rectangle4Rect.width, height: rectangle4TextHeight), withAttributes: rectangle4FontAttributes)
        context.restoreGState()
        
        
        //// Rectangle 5 Drawing
        let rectangle5Rect = CGRect(x: 677, y: 838, width: 25, height: 25)
        let rectangle5Path = UIBezierPath(rect: rectangle5Rect)
        registerBankColor.setFill()
        rectangle5Path.fill()
        black.setStroke()
        rectangle5Path.lineWidth = 1
        rectangle5Path.stroke()
        let rectangle5TextContent = "0"
        let rectangle5Style = NSMutableParagraphStyle()
        rectangle5Style.alignment = .center
        let rectangle5FontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: rectangle5Style,
            ] as [NSAttributedString.Key: Any]
        
        let rectangle5TextHeight: CGFloat = rectangle5TextContent.boundingRect(with: CGSize(width: rectangle5Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: rectangle5FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: rectangle5Rect)
        rectangle5TextContent.draw(in: CGRect(x: rectangle5Rect.minX, y: rectangle5Rect.minY + (rectangle5Rect.height - rectangle5TextHeight) / 2, width: rectangle5Rect.width, height: rectangle5TextHeight), withAttributes: rectangle5FontAttributes)
        context.restoreGState()
        
        
        //// Rectangle 6 Drawing
        let rectangle6Rect = CGRect(x: 677.5, y: 907.5, width: 25, height: 25)
        let rectangle6Path = UIBezierPath(rect: rectangle6Rect)
        registerBankColor.setFill()
        rectangle6Path.fill()
        black.setStroke()
        rectangle6Path.lineWidth = 1
        rectangle6Path.stroke()
        let rectangle6TextContent = "0"
        let rectangle6Style = NSMutableParagraphStyle()
        rectangle6Style.alignment = .center
        let rectangle6FontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: rectangle6Style,
            ] as [NSAttributedString.Key: Any]
        
        let rectangle6TextHeight: CGFloat = rectangle6TextContent.boundingRect(with: CGSize(width: rectangle6Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: rectangle6FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: rectangle6Rect)
        rectangle6TextContent.draw(in: CGRect(x: rectangle6Rect.minX, y: rectangle6Rect.minY + (rectangle6Rect.height - rectangle6TextHeight) / 2, width: rectangle6Rect.width, height: rectangle6TextHeight), withAttributes: rectangle6FontAttributes)
        context.restoreGState()
        
        
        //// Rectangle 7 Drawing
        let rectangle7Rect = CGRect(x: 594.5, y: 836.5, width: 56, height: 26)
        let rectangle7Path = UIBezierPath(rect: rectangle7Rect)
        noFillColor.setFill()
        rectangle7Path.fill()
        UIColor.black.setStroke()
        rectangle7Path.lineWidth = 1
        rectangle7Path.stroke()
        let rectangle7TextContent = "AndZ"
        let rectangle7Style = NSMutableParagraphStyle()
        rectangle7Style.alignment = .center
        let rectangle7FontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: rectangle7Style,
            ] as [NSAttributedString.Key: Any]
        
        let rectangle7TextHeight: CGFloat = rectangle7TextContent.boundingRect(with: CGSize(width: rectangle7Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: rectangle7FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: rectangle7Rect)
        rectangle7TextContent.draw(in: CGRect(x: rectangle7Rect.minX, y: rectangle7Rect.minY + (rectangle7Rect.height - rectangle7TextHeight) / 2, width: rectangle7Rect.width, height: rectangle7TextHeight), withAttributes: rectangle7FontAttributes)
        context.restoreGState()
        
        
        
        
        //// RegisterBankComponents
        //// RegisterBank Drawing
        let registerBankPath = UIBezierPath(rect: CGRect(x: 29, y: 17.51, width: 687.5, height: 175.49))
        registerBankColor.setFill()
        registerBankPath.fill()
        UIColor.black.setStroke()
        registerBankPath.lineWidth = 1
        registerBankPath.stroke()
        
        
        //// RegisterCol0
        //// ProgramCounter
        //// ProgramCounterText Drawing
        let programCounterTextRect = CGRect(x: 92.5, y: 161.5, width: 100, height: 25)
        let programCounterTextPath = UIBezierPath(rect: programCounterTextRect)
        noFillColor.setFill()
        programCounterTextPath.fill()
        UIColor.black.setStroke()
        programCounterTextPath.lineWidth = 1
        programCounterTextPath.stroke()
        let programCounterTextTextContent = "0x0000"
        let programCounterTextStyle = NSMutableParagraphStyle()
        programCounterTextStyle.alignment = .center
        let programCounterTextFontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: programCounterTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let programCounterTextTextHeight: CGFloat = programCounterTextTextContent.boundingRect(with: CGSize(width: programCounterTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: programCounterTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: programCounterTextRect)
        programCounterTextTextContent.draw(in: CGRect(x: programCounterTextRect.minX, y: programCounterTextRect.minY + (programCounterTextRect.height - programCounterTextTextHeight) / 2, width: programCounterTextRect.width, height: programCounterTextTextHeight), withAttributes: programCounterTextFontAttributes)
        context.restoreGState()
        
        
        //// PC Drawing
        let pCRect = CGRect(x: 71, y: 166, width: 19, height: 15)
        let pCStyle = NSMutableParagraphStyle()
        pCStyle.alignment = .right
        let pCFontAttributes = [
            .font: UIFont(name: "CourierNewPS-BoldMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: pCStyle,
            ] as [NSAttributedString.Key: Any]
        
        "PC".draw(in: pCRect, withAttributes: pCFontAttributes)
        
        
        //// RegText67 Drawing
        let regText67Rect = CGRect(x: 36, y: 167, width: 31, height: 13)
        let regText67TextContent = "6,7"
        let regText67Style = NSMutableParagraphStyle()
        regText67Style.alignment = .right
        let regText67FontAttributes = [
            .font: UIFont(name: "CourierNewPSMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: regText67Style,
            ] as [NSAttributedString.Key: Any]
        
        let regText67TextHeight: CGFloat = regText67TextContent.boundingRect(with: CGSize(width: regText67Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: regText67FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: regText67Rect)
        regText67TextContent.draw(in: CGRect(x: regText67Rect.minX, y: regText67Rect.minY + (regText67Rect.height - regText67TextHeight) / 2, width: regText67Rect.width, height: regText67TextHeight), withAttributes: regText67FontAttributes)
        context.restoreGState()
        
        
        
        
        //// StackPointer
        //// StackPointerText Drawing
        let stackPointerTextRect = CGRect(x: 92.5, y: 113.5, width: 100, height: 25)
        let stackPointerTextPath = UIBezierPath(rect: stackPointerTextRect)
        noFillColor.setFill()
        stackPointerTextPath.fill()
        UIColor.black.setStroke()
        stackPointerTextPath.lineWidth = 1
        stackPointerTextPath.stroke()
        let stackPointerTextTextContent = "0x0000"
        let stackPointerTextStyle = NSMutableParagraphStyle()
        stackPointerTextStyle.alignment = .center
        let stackPointerTextFontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: stackPointerTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let stackPointerTextTextHeight: CGFloat = stackPointerTextTextContent.boundingRect(with: CGSize(width: stackPointerTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: stackPointerTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: stackPointerTextRect)
        stackPointerTextTextContent.draw(in: CGRect(x: stackPointerTextRect.minX, y: stackPointerTextRect.minY + (stackPointerTextRect.height - stackPointerTextTextHeight) / 2, width: stackPointerTextRect.width, height: stackPointerTextTextHeight), withAttributes: stackPointerTextFontAttributes)
        context.restoreGState()
        
        
        //// SP Drawing
        let sPRect = CGRect(x: 71, y: 118, width: 19, height: 15)
        let sPStyle = NSMutableParagraphStyle()
        sPStyle.alignment = .right
        let sPFontAttributes = [
            .font: UIFont(name: "CourierNewPS-BoldMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: sPStyle,
            ] as [NSAttributedString.Key: Any]
        
        "SP".draw(in: sPRect, withAttributes: sPFontAttributes)
        
        
        //// RegText45 Drawing
        let regText45Rect = CGRect(x: 36, y: 119, width: 31, height: 13)
        let regText45TextContent = "4,5 "
        let regText45Style = NSMutableParagraphStyle()
        regText45Style.alignment = .right
        let regText45FontAttributes = [
            .font: UIFont(name: "CourierNewPSMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: regText45Style,
            ] as [NSAttributedString.Key: Any]
        
        let regText45TextHeight: CGFloat = regText45TextContent.boundingRect(with: CGSize(width: regText45Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: regText45FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: regText45Rect)
        regText45TextContent.draw(in: CGRect(x: regText45Rect.minX, y: regText45Rect.minY + (regText45Rect.height - regText45TextHeight) / 2, width: regText45Rect.width, height: regText45TextHeight), withAttributes: regText45FontAttributes)
        context.restoreGState()
        
        
        
        
        //// IndexRegister
        //// IndexRegisterText Drawing
        let indexRegisterTextRect = CGRect(x: 92.5, y: 68.5, width: 100, height: 25)
        let indexRegisterTextPath = UIBezierPath(rect: indexRegisterTextRect)
        noFillColor.setFill()
        indexRegisterTextPath.fill()
        UIColor.black.setStroke()
        indexRegisterTextPath.lineWidth = 1
        indexRegisterTextPath.stroke()
        let indexRegisterTextTextContent = "0x0000"
        let indexRegisterTextStyle = NSMutableParagraphStyle()
        indexRegisterTextStyle.alignment = .center
        let indexRegisterTextFontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: indexRegisterTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let indexRegisterTextTextHeight: CGFloat = indexRegisterTextTextContent.boundingRect(with: CGSize(width: indexRegisterTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: indexRegisterTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: indexRegisterTextRect)
        indexRegisterTextTextContent.draw(in: CGRect(x: indexRegisterTextRect.minX, y: indexRegisterTextRect.minY + (indexRegisterTextRect.height - indexRegisterTextTextHeight) / 2, width: indexRegisterTextRect.width, height: indexRegisterTextTextHeight), withAttributes: indexRegisterTextFontAttributes)
        context.restoreGState()
        
        
        //// X Drawing
        let xRect = CGRect(x: 71, y: 73, width: 19, height: 15)
        let xStyle = NSMutableParagraphStyle()
        xStyle.alignment = .right
        let xFontAttributes = [
            .font: UIFont(name: "CourierNewPS-BoldMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: xStyle,
            ] as [NSAttributedString.Key: Any]
        
        "X".draw(in: xRect, withAttributes: xFontAttributes)
        
        
        //// RegText23 Drawing
        let regText23Rect = CGRect(x: 36, y: 74, width: 31, height: 13)
        let regText23TextContent = "2,3"
        let regText23Style = NSMutableParagraphStyle()
        regText23Style.alignment = .right
        let regText23FontAttributes = [
            .font: UIFont(name: "CourierNewPSMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: regText23Style,
            ] as [NSAttributedString.Key: Any]
        
        let regText23TextHeight: CGFloat = regText23TextContent.boundingRect(with: CGSize(width: regText23Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: regText23FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: regText23Rect)
        regText23TextContent.draw(in: CGRect(x: regText23Rect.minX, y: regText23Rect.minY + (regText23Rect.height - regText23TextHeight) / 2, width: regText23Rect.width, height: regText23TextHeight), withAttributes: regText23FontAttributes)
        context.restoreGState()
        
        
        
        
        //// Accumulator
        //// AccumulatorText Drawing
        let accumulatorTextRect = CGRect(x: 92.5, y: 23.5, width: 100, height: 25)
        let accumulatorTextPath = UIBezierPath(rect: accumulatorTextRect)
        noFillColor.setFill()
        accumulatorTextPath.fill()
        UIColor.black.setStroke()
        accumulatorTextPath.lineWidth = 1
        accumulatorTextPath.stroke()
        let accumulatorTextTextContent = "0x0000"
        let accumulatorTextStyle = NSMutableParagraphStyle()
        accumulatorTextStyle.alignment = .center
        let accumulatorTextFontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: accumulatorTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let accumulatorTextTextHeight: CGFloat = accumulatorTextTextContent.boundingRect(with: CGSize(width: accumulatorTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: accumulatorTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: accumulatorTextRect)
        accumulatorTextTextContent.draw(in: CGRect(x: accumulatorTextRect.minX, y: accumulatorTextRect.minY + (accumulatorTextRect.height - accumulatorTextTextHeight) / 2, width: accumulatorTextRect.width, height: accumulatorTextTextHeight), withAttributes: accumulatorTextFontAttributes)
        context.restoreGState()
        
        
        //// A Drawing
        let aRect = CGRect(x: 71, y: 28, width: 19, height: 15)
        let aStyle = NSMutableParagraphStyle()
        aStyle.alignment = .right
        let aFontAttributes = [
            .font: UIFont(name: "CourierNewPS-BoldMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: aStyle,
            ] as [NSAttributedString.Key: Any]
        
        "A".draw(in: aRect, withAttributes: aFontAttributes)
        
        
        //// RegText01 Drawing
        let regText01Rect = CGRect(x: 36, y: 29, width: 31, height: 13)
        let regText01TextContent = "0,1 "
        let regText01Style = NSMutableParagraphStyle()
        regText01Style.alignment = .right
        let regText01FontAttributes = [
            .font: UIFont(name: "CourierNewPSMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: regText01Style,
            ] as [NSAttributedString.Key: Any]
        
        let regText01TextHeight: CGFloat = regText01TextContent.boundingRect(with: CGSize(width: regText01Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: regText01FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: regText01Rect)
        regText01TextContent.draw(in: CGRect(x: regText01Rect.minX, y: regText01Rect.minY + (regText01Rect.height - regText01TextHeight) / 2, width: regText01Rect.width, height: regText01TextHeight), withAttributes: regText01FontAttributes)
        context.restoreGState()
        
        
        
        
        
        
        //// RegisterCol1
        //// T3Register
        //// T3RegText Drawing
        let t3RegTextRect = CGRect(x: 274.5, y: 161.5, width: 100, height: 25)
        let t3RegTextPath = UIBezierPath(rect: t3RegTextRect)
        noFillColor.setFill()
        t3RegTextPath.fill()
        UIColor.black.setStroke()
        t3RegTextPath.lineWidth = 1
        t3RegTextPath.stroke()
        let t3RegTextTextContent = "0x0000"
        let t3RegTextStyle = NSMutableParagraphStyle()
        t3RegTextStyle.alignment = .center
        let t3RegTextFontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: t3RegTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let t3RegTextTextHeight: CGFloat = t3RegTextTextContent.boundingRect(with: CGSize(width: t3RegTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: t3RegTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: t3RegTextRect)
        t3RegTextTextContent.draw(in: CGRect(x: t3RegTextRect.minX, y: t3RegTextRect.minY + (t3RegTextRect.height - t3RegTextTextHeight) / 2, width: t3RegTextRect.width, height: t3RegTextTextHeight), withAttributes: t3RegTextFontAttributes)
        context.restoreGState()
        
        
        //// T3 Drawing
        let t3Rect = CGRect(x: 253, y: 166, width: 19, height: 15)
        let t3Style = NSMutableParagraphStyle()
        t3Style.alignment = .right
        let t3FontAttributes = [
            .font: UIFont(name: "CourierNewPS-BoldMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: t3Style,
            ] as [NSAttributedString.Key: Any]
        
        "T3".draw(in: t3Rect, withAttributes: t3FontAttributes)
        
        
        //// RegText1415 Drawing
        let regText1415Rect = CGRect(x: 206, y: 168, width: 46, height: 13)
        let regText1415TextContent = "14,15"
        let regText1415Style = NSMutableParagraphStyle()
        regText1415Style.alignment = .left
        let regText1415FontAttributes = [
            .font: UIFont(name: "CourierNewPSMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: regText1415Style,
            ] as [NSAttributedString.Key: Any]
        
        let regText1415TextHeight: CGFloat = regText1415TextContent.boundingRect(with: CGSize(width: regText1415Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: regText1415FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: regText1415Rect)
        regText1415TextContent.draw(in: CGRect(x: regText1415Rect.minX, y: regText1415Rect.minY + (regText1415Rect.height - regText1415TextHeight) / 2, width: regText1415Rect.width, height: regText1415TextHeight), withAttributes: regText1415FontAttributes)
        context.restoreGState()
        
        
        
        
        //// T2Register
        //// T2RegText Drawing
        let t2RegTextRect = CGRect(x: 274.5, y: 113.5, width: 100, height: 25)
        let t2RegTextPath = UIBezierPath(rect: t2RegTextRect)
        noFillColor.setFill()
        t2RegTextPath.fill()
        UIColor.black.setStroke()
        t2RegTextPath.lineWidth = 1
        t2RegTextPath.stroke()
        let t2RegTextTextContent = "0x0000"
        let t2RegTextStyle = NSMutableParagraphStyle()
        t2RegTextStyle.alignment = .center
        let t2RegTextFontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: t2RegTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let t2RegTextTextHeight: CGFloat = t2RegTextTextContent.boundingRect(with: CGSize(width: t2RegTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: t2RegTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: t2RegTextRect)
        t2RegTextTextContent.draw(in: CGRect(x: t2RegTextRect.minX, y: t2RegTextRect.minY + (t2RegTextRect.height - t2RegTextTextHeight) / 2, width: t2RegTextRect.width, height: t2RegTextTextHeight), withAttributes: t2RegTextFontAttributes)
        context.restoreGState()
        
        
        //// T2 Drawing
        let t2Rect = CGRect(x: 253, y: 118, width: 19, height: 15)
        let t2Style = NSMutableParagraphStyle()
        t2Style.alignment = .right
        let t2FontAttributes = [
            .font: UIFont(name: "CourierNewPS-BoldMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: t2Style,
            ] as [NSAttributedString.Key: Any]
        
        "T2".draw(in: t2Rect, withAttributes: t2FontAttributes)
        
        
        //// RegText1213 Drawing
        let regText1213Rect = CGRect(x: 206, y: 120, width: 46, height: 13)
        let regText1213TextContent = "12,13"
        let regText1213Style = NSMutableParagraphStyle()
        regText1213Style.alignment = .left
        let regText1213FontAttributes = [
            .font: UIFont(name: "CourierNewPSMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: regText1213Style,
            ] as [NSAttributedString.Key: Any]
        
        let regText1213TextHeight: CGFloat = regText1213TextContent.boundingRect(with: CGSize(width: regText1213Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: regText1213FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: regText1213Rect)
        regText1213TextContent.draw(in: CGRect(x: regText1213Rect.minX, y: regText1213Rect.minY + (regText1213Rect.height - regText1213TextHeight) / 2, width: regText1213Rect.width, height: regText1213TextHeight), withAttributes: regText1213FontAttributes)
        context.restoreGState()
        
        
        
        
        //// T1Register
        //// T1RegText Drawing
        let t1RegTextRect = CGRect(x: 274.5, y: 68.5, width: 100, height: 25)
        let t1RegTextPath = UIBezierPath(rect: t1RegTextRect)
        noFillColor.setFill()
        t1RegTextPath.fill()
        UIColor.black.setStroke()
        t1RegTextPath.lineWidth = 1
        t1RegTextPath.stroke()
        let t1RegTextTextContent = "0x00"
        let t1RegTextStyle = NSMutableParagraphStyle()
        t1RegTextStyle.alignment = .center
        let t1RegTextFontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: t1RegTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let t1RegTextTextHeight: CGFloat = t1RegTextTextContent.boundingRect(with: CGSize(width: t1RegTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: t1RegTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: t1RegTextRect)
        t1RegTextTextContent.draw(in: CGRect(x: t1RegTextRect.minX, y: t1RegTextRect.minY + (t1RegTextRect.height - t1RegTextTextHeight) / 2, width: t1RegTextRect.width, height: t1RegTextTextHeight), withAttributes: t1RegTextFontAttributes)
        context.restoreGState()
        
        
        //// T1 Drawing
        let t1Rect = CGRect(x: 253, y: 73, width: 19, height: 15)
        let t1Style = NSMutableParagraphStyle()
        t1Style.alignment = .right
        let t1FontAttributes = [
            .font: UIFont(name: "CourierNewPS-BoldMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: t1Style,
            ] as [NSAttributedString.Key: Any]
        
        "T1".draw(in: t1Rect, withAttributes: t1FontAttributes)
        
        
        //// RegText11 Drawing
        let regText11Rect = CGRect(x: 218, y: 74, width: 31, height: 13)
        let regText11TextContent = "11"
        let regText11Style = NSMutableParagraphStyle()
        regText11Style.alignment = .right
        let regText11FontAttributes = [
            .font: UIFont(name: "CourierNewPSMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: regText11Style,
            ] as [NSAttributedString.Key: Any]
        
        let regText11TextHeight: CGFloat = regText11TextContent.boundingRect(with: CGSize(width: regText11Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: regText11FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: regText11Rect)
        regText11TextContent.draw(in: CGRect(x: regText11Rect.minX, y: regText11Rect.minY + (regText11Rect.height - regText11TextHeight) / 2, width: regText11Rect.width, height: regText11TextHeight), withAttributes: regText11FontAttributes)
        context.restoreGState()
        
        
        
        
        //// InstrRegister
        //// InstrRegText Drawing
        let instrRegTextRect = CGRect(x: 274.5, y: 23.5, width: 100, height: 25)
        let instrRegTextPath = UIBezierPath(rect: instrRegTextRect)
        noFillColor.setFill()
        instrRegTextPath.fill()
        UIColor.black.setStroke()
        instrRegTextPath.lineWidth = 1
        instrRegTextPath.stroke()
        let instrRegTextTextContent = "0x000000"
        let instrRegTextStyle = NSMutableParagraphStyle()
        instrRegTextStyle.alignment = .center
        let instrRegTextFontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: instrRegTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let instrRegTextTextHeight: CGFloat = instrRegTextTextContent.boundingRect(with: CGSize(width: instrRegTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: instrRegTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: instrRegTextRect)
        instrRegTextTextContent.draw(in: CGRect(x: instrRegTextRect.minX, y: instrRegTextRect.minY + (instrRegTextRect.height - instrRegTextTextHeight) / 2, width: instrRegTextRect.width, height: instrRegTextTextHeight), withAttributes: instrRegTextFontAttributes)
        context.restoreGState()
        
        
        //// IR Drawing
        let iRRect = CGRect(x: 253, y: 28, width: 19, height: 15)
        let iRStyle = NSMutableParagraphStyle()
        iRStyle.alignment = .right
        let iRFontAttributes = [
            .font: UIFont(name: "CourierNewPS-BoldMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: iRStyle,
            ] as [NSAttributedString.Key: Any]
        
        "IR\n".draw(in: iRRect, withAttributes: iRFontAttributes)
        
        
        //// RegText8-10 Drawing
        let regText810Rect = CGRect(x: 215, y: 30, width: 45, height: 13)
        let regText810TextContent = "8-10"
        let regText810Style = NSMutableParagraphStyle()
        regText810Style.alignment = .left
        let regText810FontAttributes = [
            .font: UIFont(name: "CourierNewPSMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: regText810Style,
            ] as [NSAttributedString.Key: Any]
        
        let regText810TextHeight: CGFloat = regText810TextContent.boundingRect(with: CGSize(width: regText810Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: regText810FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: regText810Rect)
        regText810TextContent.draw(in: CGRect(x: regText810Rect.minX, y: regText810Rect.minY + (regText810Rect.height - regText810TextHeight) / 2, width: regText810Rect.width, height: regText810TextHeight), withAttributes: regText810FontAttributes)
        context.restoreGState()
        
        
        
        
        
        
        //// RegisterCol2
        //// M1Register
        //// M1Text Drawing
        let m1TextRect = CGRect(x: 453.5, y: 161.5, width: 100, height: 25)
        let m1TextTextContent = "0x0001"
        let m1TextStyle = NSMutableParagraphStyle()
        m1TextStyle.alignment = .center
        let m1TextFontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: m1TextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let m1TextTextHeight: CGFloat = m1TextTextContent.boundingRect(with: CGSize(width: m1TextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: m1TextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: m1TextRect)
        m1TextTextContent.draw(in: CGRect(x: m1TextRect.minX, y: m1TextRect.minY + (m1TextRect.height - m1TextTextHeight) / 2, width: m1TextRect.width, height: m1TextTextHeight), withAttributes: m1TextFontAttributes)
        context.restoreGState()
        
        
        //// M1 Drawing
        let m1Rect = CGRect(x: 432, y: 166, width: 19, height: 15)
        let m1Style = NSMutableParagraphStyle()
        m1Style.alignment = .right
        let m1FontAttributes = [
            .font: UIFont(name: "CourierNewPS-BoldMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: m1Style,
            ] as [NSAttributedString.Key: Any]
        
        "M1\n".draw(in: m1Rect, withAttributes: m1FontAttributes)
        
        
        //// RegText2223 Drawing
        let regText2223Rect = CGRect(x: 385, y: 168, width: 46, height: 13)
        let regText2223TextContent = "22,23"
        let regText2223Style = NSMutableParagraphStyle()
        regText2223Style.alignment = .left
        let regText2223FontAttributes = [
            .font: UIFont(name: "CourierNewPSMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: regText2223Style,
            ] as [NSAttributedString.Key: Any]
        
        let regText2223TextHeight: CGFloat = regText2223TextContent.boundingRect(with: CGSize(width: regText2223Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: regText2223FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: regText2223Rect)
        regText2223TextContent.draw(in: CGRect(x: regText2223Rect.minX, y: regText2223Rect.minY + (regText2223Rect.height - regText2223TextHeight) / 2, width: regText2223Rect.width, height: regText2223TextHeight), withAttributes: regText2223FontAttributes)
        context.restoreGState()
        
        
        
        
        //// T6Register
        //// T6RegText2 Drawing
        let t6RegText2Rect = CGRect(x: 453.5, y: 113.5, width: 100, height: 25)
        let t6RegText2Path = UIBezierPath(rect: t6RegText2Rect)
        noFillColor.setFill()
        t6RegText2Path.fill()
        UIColor.black.setStroke()
        t6RegText2Path.lineWidth = 1
        t6RegText2Path.stroke()
        let t6RegText2TextContent = "0x0000"
        let t6RegText2Style = NSMutableParagraphStyle()
        t6RegText2Style.alignment = .center
        let t6RegText2FontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: t6RegText2Style,
            ] as [NSAttributedString.Key: Any]
        
        let t6RegText2TextHeight: CGFloat = t6RegText2TextContent.boundingRect(with: CGSize(width: t6RegText2Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: t6RegText2FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: t6RegText2Rect)
        t6RegText2TextContent.draw(in: CGRect(x: t6RegText2Rect.minX, y: t6RegText2Rect.minY + (t6RegText2Rect.height - t6RegText2TextHeight) / 2, width: t6RegText2Rect.width, height: t6RegText2TextHeight), withAttributes: t6RegText2FontAttributes)
        context.restoreGState()
        
        
        //// T6 Drawing
        let t6Rect = CGRect(x: 432, y: 118, width: 19, height: 15)
        let t6Style = NSMutableParagraphStyle()
        t6Style.alignment = .right
        let t6FontAttributes = [
            .font: UIFont(name: "CourierNewPS-BoldMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: t6Style,
            ] as [NSAttributedString.Key: Any]
        
        "T6".draw(in: t6Rect, withAttributes: t6FontAttributes)
        
        
        //// RegText2021 Drawing
        let regText2021Rect = CGRect(x: 385, y: 120, width: 46, height: 13)
        let regText2021TextContent = "20,21"
        let regText2021Style = NSMutableParagraphStyle()
        regText2021Style.alignment = .left
        let regText2021FontAttributes = [
            .font: UIFont(name: "CourierNewPSMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: regText2021Style,
            ] as [NSAttributedString.Key: Any]
        
        let regText2021TextHeight: CGFloat = regText2021TextContent.boundingRect(with: CGSize(width: regText2021Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: regText2021FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: regText2021Rect)
        regText2021TextContent.draw(in: CGRect(x: regText2021Rect.minX, y: regText2021Rect.minY + (regText2021Rect.height - regText2021TextHeight) / 2, width: regText2021Rect.width, height: regText2021TextHeight), withAttributes: regText2021FontAttributes)
        context.restoreGState()
        
        
        
        
        //// T5Register
        //// T5RegText Drawing
        let t5RegTextRect = CGRect(x: 453.5, y: 68.5, width: 100, height: 25)
        let t5RegTextPath = UIBezierPath(rect: t5RegTextRect)
        noFillColor.setFill()
        t5RegTextPath.fill()
        UIColor.black.setStroke()
        t5RegTextPath.lineWidth = 1
        t5RegTextPath.stroke()
        let t5RegTextTextContent = "0x0000"
        let t5RegTextStyle = NSMutableParagraphStyle()
        t5RegTextStyle.alignment = .center
        let t5RegTextFontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: t5RegTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let t5RegTextTextHeight: CGFloat = t5RegTextTextContent.boundingRect(with: CGSize(width: t5RegTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: t5RegTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: t5RegTextRect)
        t5RegTextTextContent.draw(in: CGRect(x: t5RegTextRect.minX, y: t5RegTextRect.minY + (t5RegTextRect.height - t5RegTextTextHeight) / 2, width: t5RegTextRect.width, height: t5RegTextTextHeight), withAttributes: t5RegTextFontAttributes)
        context.restoreGState()
        
        
        //// T5 Drawing
        let t5Rect = CGRect(x: 432, y: 73, width: 19, height: 15)
        let t5Style = NSMutableParagraphStyle()
        t5Style.alignment = .right
        let t5FontAttributes = [
            .font: UIFont(name: "CourierNewPS-BoldMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: t5Style,
            ] as [NSAttributedString.Key: Any]
        
        "T5".draw(in: t5Rect, withAttributes: t5FontAttributes)
        
        
        //// RegText1718 Drawing
        let regText1718Rect = CGRect(x: 385, y: 75, width: 46, height: 13)
        let regText1718TextContent = "17,18"
        let regText1718Style = NSMutableParagraphStyle()
        regText1718Style.alignment = .left
        let regText1718FontAttributes = [
            .font: UIFont(name: "CourierNewPSMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: regText1718Style,
            ] as [NSAttributedString.Key: Any]
        
        let regText1718TextHeight: CGFloat = regText1718TextContent.boundingRect(with: CGSize(width: regText1718Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: regText1718FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: regText1718Rect)
        regText1718TextContent.draw(in: CGRect(x: regText1718Rect.minX, y: regText1718Rect.minY + (regText1718Rect.height - regText1718TextHeight) / 2, width: regText1718Rect.width, height: regText1718TextHeight), withAttributes: regText1718FontAttributes)
        context.restoreGState()
        
        
        
        
        //// T4Register
        //// T4RegText Drawing
        let t4RegTextRect = CGRect(x: 453.5, y: 23.5, width: 100, height: 25)
        let t4RegTextPath = UIBezierPath(rect: t4RegTextRect)
        noFillColor.setFill()
        t4RegTextPath.fill()
        UIColor.black.setStroke()
        t4RegTextPath.lineWidth = 1
        t4RegTextPath.stroke()
        let t4RegTextTextContent = "0x0000"
        let t4RegTextStyle = NSMutableParagraphStyle()
        t4RegTextStyle.alignment = .center
        let t4RegTextFontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: t4RegTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let t4RegTextTextHeight: CGFloat = t4RegTextTextContent.boundingRect(with: CGSize(width: t4RegTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: t4RegTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: t4RegTextRect)
        t4RegTextTextContent.draw(in: CGRect(x: t4RegTextRect.minX, y: t4RegTextRect.minY + (t4RegTextRect.height - t4RegTextTextHeight) / 2, width: t4RegTextRect.width, height: t4RegTextTextHeight), withAttributes: t4RegTextFontAttributes)
        context.restoreGState()
        
        
        //// T4 Drawing
        let t4Rect = CGRect(x: 432, y: 28, width: 19, height: 15)
        let t4Style = NSMutableParagraphStyle()
        t4Style.alignment = .right
        let t4FontAttributes = [
            .font: UIFont(name: "CourierNewPS-BoldMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: t4Style,
            ] as [NSAttributedString.Key: Any]
        
        "T4\n\n".draw(in: t4Rect, withAttributes: t4FontAttributes)
        
        
        //// RegTex1617 Drawing
        let regTex1617Rect = CGRect(x: 385, y: 30, width: 46, height: 13)
        let regTex1617TextContent = "16,17"
        let regTex1617Style = NSMutableParagraphStyle()
        regTex1617Style.alignment = .left
        let regTex1617FontAttributes = [
            .font: UIFont(name: "CourierNewPSMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: regTex1617Style,
            ] as [NSAttributedString.Key: Any]
        
        let regTex1617TextHeight: CGFloat = regTex1617TextContent.boundingRect(with: CGSize(width: regTex1617Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: regTex1617FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: regTex1617Rect)
        regTex1617TextContent.draw(in: CGRect(x: regTex1617Rect.minX, y: regTex1617Rect.minY + (regTex1617Rect.height - regTex1617TextHeight) / 2, width: regTex1617Rect.width, height: regTex1617TextHeight), withAttributes: regTex1617FontAttributes)
        context.restoreGState()
        
        
        
        
        
        
        //// RegisterCol3
        //// M5Register
        //// M5Text Drawing
        let m5TextRect = CGRect(x: 626.5, y: 161.5, width: 100, height: 25)
        let m5TextTextContent = "0xFEFF"
        let m5TextStyle = NSMutableParagraphStyle()
        m5TextStyle.alignment = .center
        let m5TextFontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: m5TextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let m5TextTextHeight: CGFloat = m5TextTextContent.boundingRect(with: CGSize(width: m5TextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: m5TextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: m5TextRect)
        m5TextTextContent.draw(in: CGRect(x: m5TextRect.minX, y: m5TextRect.minY + (m5TextRect.height - m5TextTextHeight) / 2, width: m5TextRect.width, height: m5TextTextHeight), withAttributes: m5TextFontAttributes)
        context.restoreGState()
        
        
        //// M5 Drawing
        let m5Rect = CGRect(x: 618, y: 166, width: 19, height: 15)
        let m5Style = NSMutableParagraphStyle()
        m5Style.alignment = .right
        let m5FontAttributes = [
            .font: UIFont(name: "CourierNewPS-BoldMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: m5Style,
            ] as [NSAttributedString.Key: Any]
        
        "M5\n".draw(in: m5Rect, withAttributes: m5FontAttributes)
        
        
        //// RegText3031 Drawing
        let regText3031Rect = CGRect(x: 568, y: 168, width: 46, height: 13)
        let regText3031TextContent = "30,31"
        let regText3031Style = NSMutableParagraphStyle()
        regText3031Style.alignment = .left
        let regText3031FontAttributes = [
            .font: UIFont(name: "CourierNewPSMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: regText3031Style,
            ] as [NSAttributedString.Key: Any]
        
        let regText3031TextHeight: CGFloat = regText3031TextContent.boundingRect(with: CGSize(width: regText3031Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: regText3031FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: regText3031Rect)
        regText3031TextContent.draw(in: CGRect(x: regText3031Rect.minX, y: regText3031Rect.minY + (regText3031Rect.height - regText3031TextHeight) / 2, width: regText3031Rect.width, height: regText3031TextHeight), withAttributes: regText3031FontAttributes)
        context.restoreGState()
        
        
        
        
        //// M4Register
        //// M4RegText Drawing
        let m4RegTextRect = CGRect(x: 626.5, y: 113.5, width: 100, height: 25)
        let m4RegTextTextContent = "0xF0F6"
        let m4RegTextStyle = NSMutableParagraphStyle()
        m4RegTextStyle.alignment = .center
        let m4RegTextFontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: m4RegTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let m4RegTextTextHeight: CGFloat = m4RegTextTextContent.boundingRect(with: CGSize(width: m4RegTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: m4RegTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: m4RegTextRect)
        m4RegTextTextContent.draw(in: CGRect(x: m4RegTextRect.minX, y: m4RegTextRect.minY + (m4RegTextRect.height - m4RegTextTextHeight) / 2, width: m4RegTextRect.width, height: m4RegTextTextHeight), withAttributes: m4RegTextFontAttributes)
        context.restoreGState()
        
        
        //// M4 Drawing
        let m4Rect = CGRect(x: 618, y: 118, width: 19, height: 15)
        let m4Style = NSMutableParagraphStyle()
        m4Style.alignment = .right
        let m4FontAttributes = [
            .font: UIFont(name: "CourierNewPS-BoldMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: m4Style,
            ] as [NSAttributedString.Key: Any]
        
        "M4".draw(in: m4Rect, withAttributes: m4FontAttributes)
        
        
        //// RegText2829 Drawing
        let regText2829Rect = CGRect(x: 568, y: 120, width: 46, height: 13)
        let regText2829TextContent = "28,29"
        let regText2829Style = NSMutableParagraphStyle()
        regText2829Style.alignment = .left
        let regText2829FontAttributes = [
            .font: UIFont(name: "CourierNewPSMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: regText2829Style,
            ] as [NSAttributedString.Key: Any]
        
        let regText2829TextHeight: CGFloat = regText2829TextContent.boundingRect(with: CGSize(width: regText2829Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: regText2829FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: regText2829Rect)
        regText2829TextContent.draw(in: CGRect(x: regText2829Rect.minX, y: regText2829Rect.minY + (regText2829Rect.height - regText2829TextHeight) / 2, width: regText2829Rect.width, height: regText2829TextHeight), withAttributes: regText2829FontAttributes)
        context.restoreGState()
        
        
        
        
        //// M3Register
        //// M3RegText Drawing
        let m3RegTextRect = CGRect(x: 626.5, y: 68.5, width: 100, height: 25)
        let m3RegTextTextContent = "0x0408"
        let m3RegTextStyle = NSMutableParagraphStyle()
        m3RegTextStyle.alignment = .center
        let m3RegTextFontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: m3RegTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let m3RegTextTextHeight: CGFloat = m3RegTextTextContent.boundingRect(with: CGSize(width: m3RegTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: m3RegTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: m3RegTextRect)
        m3RegTextTextContent.draw(in: CGRect(x: m3RegTextRect.minX, y: m3RegTextRect.minY + (m3RegTextRect.height - m3RegTextTextHeight) / 2, width: m3RegTextRect.width, height: m3RegTextTextHeight), withAttributes: m3RegTextFontAttributes)
        context.restoreGState()
        
        
        //// M3 Drawing
        let m3Rect = CGRect(x: 618, y: 73, width: 19, height: 15)
        let m3Style = NSMutableParagraphStyle()
        m3Style.alignment = .right
        let m3FontAttributes = [
            .font: UIFont(name: "CourierNewPS-BoldMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: m3Style,
            ] as [NSAttributedString.Key: Any]
        
        "M3".draw(in: m3Rect, withAttributes: m3FontAttributes)
        
        
        //// RegText2627 Drawing
        let regText2627Rect = CGRect(x: 568, y: 75, width: 46, height: 13)
        let regText2627TextContent = "26,27"
        let regText2627Style = NSMutableParagraphStyle()
        regText2627Style.alignment = .left
        let regText2627FontAttributes = [
            .font: UIFont(name: "CourierNewPSMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: regText2627Style,
            ] as [NSAttributedString.Key: Any]
        
        let regText2627TextHeight: CGFloat = regText2627TextContent.boundingRect(with: CGSize(width: regText2627Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: regText2627FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: regText2627Rect)
        regText2627TextContent.draw(in: CGRect(x: regText2627Rect.minX, y: regText2627Rect.minY + (regText2627Rect.height - regText2627TextHeight) / 2, width: regText2627Rect.width, height: regText2627TextHeight), withAttributes: regText2627FontAttributes)
        context.restoreGState()
        
        
        
        
        //// M2Register
        //// M2RegText Drawing
        let m2RegTextRect = CGRect(x: 626.5, y: 23.5, width: 100, height: 25)
        let m2RegTextTextContent = "0x0203"
        let m2RegTextStyle = NSMutableParagraphStyle()
        m2RegTextStyle.alignment = .center
        let m2RegTextFontAttributes = [
            .font: UIFont(name: "HelveticaNeue", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: m2RegTextStyle,
            ] as [NSAttributedString.Key: Any]
        
        let m2RegTextTextHeight: CGFloat = m2RegTextTextContent.boundingRect(with: CGSize(width: m2RegTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: m2RegTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: m2RegTextRect)
        m2RegTextTextContent.draw(in: CGRect(x: m2RegTextRect.minX, y: m2RegTextRect.minY + (m2RegTextRect.height - m2RegTextTextHeight) / 2, width: m2RegTextRect.width, height: m2RegTextTextHeight), withAttributes: m2RegTextFontAttributes)
        context.restoreGState()
        
        
        //// M2 Drawing
        let m2Rect = CGRect(x: 618, y: 28, width: 19, height: 15)
        let m2Style = NSMutableParagraphStyle()
        m2Style.alignment = .right
        let m2FontAttributes = [
            .font: UIFont(name: "CourierNewPS-BoldMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: m2Style,
            ] as [NSAttributedString.Key: Any]
        
        "M2\n\n".draw(in: m2Rect, withAttributes: m2FontAttributes)
        
        
        //// RegTex2425 Drawing
        let regTex2425Rect = CGRect(x: 568, y: 30, width: 46, height: 13)
        let regTex2425TextContent = "24,25"
        let regTex2425Style = NSMutableParagraphStyle()
        regTex2425Style.alignment = .left
        let regTex2425FontAttributes = [
            .font: UIFont(name: "CourierNewPSMT", size: 15)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: regTex2425Style,
            ] as [NSAttributedString.Key: Any]
        
        let regTex2425TextHeight: CGFloat = regTex2425TextContent.boundingRect(with: CGSize(width: regTex2425Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: regTex2425FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: regTex2425Rect)
        regTex2425TextContent.draw(in: CGRect(x: regTex2425Rect.minX, y: regTex2425Rect.minY + (regTex2425Rect.height - regTex2425TextHeight) / 2, width: regTex2425Rect.width, height: regTex2425TextHeight), withAttributes: regTex2425FontAttributes)
        context.restoreGState()


    }

    @objc public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}
